"""
Dataset Generation
Topology Optimization of a Cantilever Beam
--------------------------------------------------------------------
Laboratory of Topology Optimization and Multiphysics Analysis
Department of Computational Mechanics
School of Mechanical Engineering
University of Campinas (Brazil)
--------------------------------------------------------------------
author  : Daniel Candeloro Cunha
version : 1.0
date    : May 2022
--------------------------------------------------------------------
To collaborate or report bugs, please look for the author's email
address at https://www.fem.unicamp.br/~ltm/

All codes and documentation are publicly available in the following
github repository: https://github.com/Joquempo/Cantilever-Dataset

If you use this program (or the data generated by it) in your work,
the developer would be grateful if you would cite the indicated
references. They are listed in the "CITEAS" file available in the
github repository.
--------------------------------------------------------------------
Copyright (C) 2022 Daniel Candeloro Cunha

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses
"""

# distutils: extra_compile_args=-fopenmp
# distutils: extra_link_args=-fopenmp
# cython: boundscheck=False
# cython: wraparound=False
# cython: cdivision=True

cimport cython
from libc.stdlib cimport malloc, free
from cython.parallel cimport prange, parallel

# from https://github.com/willnode/N-Matrix-Programmer
cdef void inv_4x4(double **A, double **Ainv) nogil:
    cdef double A2323
    cdef double A1323
    cdef double A1223
    cdef double A0323
    cdef double A0223
    cdef double A0123
    cdef double A2313
    cdef double A1313
    cdef double A1213
    cdef double A2312
    cdef double A1312
    cdef double A1212
    cdef double A0313
    cdef double A0213
    cdef double A0312
    cdef double A0212
    cdef double A0113
    cdef double A0112
    cdef double det
    A2323 = A[2][2] * A[3][3] - A[2][3] * A[3][2]
    A1323 = A[2][1] * A[3][3] - A[2][3] * A[3][1]
    A1223 = A[2][1] * A[3][2] - A[2][2] * A[3][1]
    A0323 = A[2][0] * A[3][3] - A[2][3] * A[3][0]
    A0223 = A[2][0] * A[3][2] - A[2][2] * A[3][0]
    A0123 = A[2][0] * A[3][1] - A[2][1] * A[3][0]
    A2313 = A[1][2] * A[3][3] - A[1][3] * A[3][2]
    A1313 = A[1][1] * A[3][3] - A[1][3] * A[3][1]
    A1213 = A[1][1] * A[3][2] - A[1][2] * A[3][1]
    A2312 = A[1][2] * A[2][3] - A[1][3] * A[2][2]
    A1312 = A[1][1] * A[2][3] - A[1][3] * A[2][1]
    A1212 = A[1][1] * A[2][2] - A[1][2] * A[2][1]
    A0313 = A[1][0] * A[3][3] - A[1][3] * A[3][0]
    A0213 = A[1][0] * A[3][2] - A[1][2] * A[3][0]
    A0312 = A[1][0] * A[2][3] - A[1][3] * A[2][0]
    A0212 = A[1][0] * A[2][2] - A[1][2] * A[2][0]
    A0113 = A[1][0] * A[3][1] - A[1][1] * A[3][0]
    A0112 = A[1][0] * A[2][1] - A[1][1] * A[2][0]
    det = A[0][0]*(A[1][1]*A2323-A[1][2]*A1323+A[1][3]*A1223) - A[0][1]*(A[1][0]*A2323-A[1][2]*A0323+A[1][3]*A0223) + A[0][2]*(A[1][0]*A1323-A[1][1]*A0323+A[1][3]*A0123) - A[0][3]*(A[1][0]*A1223-A[1][1]*A0223+A[1][2]*A0123)
    det = 1.0/det
    Ainv[0][0] = det *   ( A[1][1] * A2323 - A[1][2] * A1323 + A[1][3] * A1223 )
    Ainv[0][1] = det * - ( A[0][1] * A2323 - A[0][2] * A1323 + A[0][3] * A1223 )
    Ainv[0][2] = det *   ( A[0][1] * A2313 - A[0][2] * A1313 + A[0][3] * A1213 )
    Ainv[0][3] = det * - ( A[0][1] * A2312 - A[0][2] * A1312 + A[0][3] * A1212 )
    Ainv[1][0] = det * - ( A[1][0] * A2323 - A[1][2] * A0323 + A[1][3] * A0223 )
    Ainv[1][1] = det *   ( A[0][0] * A2323 - A[0][2] * A0323 + A[0][3] * A0223 )
    Ainv[1][2] = det * - ( A[0][0] * A2313 - A[0][2] * A0313 + A[0][3] * A0213 )
    Ainv[1][3] = det *   ( A[0][0] * A2312 - A[0][2] * A0312 + A[0][3] * A0212 )
    Ainv[2][0] = det *   ( A[1][0] * A1323 - A[1][1] * A0323 + A[1][3] * A0123 )
    Ainv[2][1] = det * - ( A[0][0] * A1323 - A[0][1] * A0323 + A[0][3] * A0123 )
    Ainv[2][2] = det *   ( A[0][0] * A1313 - A[0][1] * A0313 + A[0][3] * A0113 )
    Ainv[2][3] = det * - ( A[0][0] * A1312 - A[0][1] * A0312 + A[0][3] * A0112 )
    Ainv[3][0] = det * - ( A[1][0] * A1223 - A[1][1] * A0223 + A[1][2] * A0123 )
    Ainv[3][1] = det *   ( A[0][0] * A1223 - A[0][1] * A0223 + A[0][2] * A0123 )
    Ainv[3][2] = det * - ( A[0][0] * A1213 - A[0][1] * A0213 + A[0][2] * A0113 )
    Ainv[3][3] = det *   ( A[0][0] * A1212 - A[0][1] * A0212 + A[0][2] * A0112 )
    return

# from https://github.com/willnode/N-Matrix-Programmer
cdef void inv_5x5(double **A, double **Ainv) nogil:
    cdef double A3434
    cdef double A2434
    cdef double A2334
    cdef double A1434
    cdef double A1334
    cdef double A1234
    cdef double A0434
    cdef double A0334
    cdef double A0234
    cdef double A0134
    cdef double A3424
    cdef double A2424
    cdef double A2324
    cdef double A1424
    cdef double A1324
    cdef double A1224
    cdef double A3423
    cdef double A2423
    cdef double A2323
    cdef double A1423
    cdef double A1323
    cdef double A1223
    cdef double A0424
    cdef double A0324
    cdef double A0224
    cdef double A0423
    cdef double A0323
    cdef double A0223
    cdef double A0124
    cdef double A0123
    cdef double B234234
    cdef double B134234
    cdef double B124234
    cdef double B123234
    cdef double B034234
    cdef double B024234
    cdef double B023234
    cdef double B014234
    cdef double B013234
    cdef double B012234
    cdef double B234134
    cdef double B134134
    cdef double B124134
    cdef double B123134
    cdef double B234124
    cdef double B134124
    cdef double B124124
    cdef double B123124
    cdef double B234123
    cdef double B134123
    cdef double B124123
    cdef double B123123
    cdef double B034134
    cdef double B024134
    cdef double B023134
    cdef double B034124
    cdef double B024124
    cdef double B023124
    cdef double B034123
    cdef double B024123
    cdef double B023123
    cdef double B014134
    cdef double B013134
    cdef double B014124
    cdef double B013124
    cdef double B014123
    cdef double B013123
    cdef double B012134
    cdef double B012124
    cdef double B012123
    cdef double det
    A3434 = A[3][3] * A[4][4] - A[3][4] * A[4][3]
    A2434 = A[3][2] * A[4][4] - A[3][4] * A[4][2]
    A2334 = A[3][2] * A[4][3] - A[3][3] * A[4][2]
    A1434 = A[3][1] * A[4][4] - A[3][4] * A[4][1]
    A1334 = A[3][1] * A[4][3] - A[3][3] * A[4][1]
    A1234 = A[3][1] * A[4][2] - A[3][2] * A[4][1]
    A0434 = A[3][0] * A[4][4] - A[3][4] * A[4][0]
    A0334 = A[3][0] * A[4][3] - A[3][3] * A[4][0]
    A0234 = A[3][0] * A[4][2] - A[3][2] * A[4][0]
    A0134 = A[3][0] * A[4][1] - A[3][1] * A[4][0]
    A3424 = A[2][3] * A[4][4] - A[2][4] * A[4][3]
    A2424 = A[2][2] * A[4][4] - A[2][4] * A[4][2]
    A2324 = A[2][2] * A[4][3] - A[2][3] * A[4][2]
    A1424 = A[2][1] * A[4][4] - A[2][4] * A[4][1]
    A1324 = A[2][1] * A[4][3] - A[2][3] * A[4][1]
    A1224 = A[2][1] * A[4][2] - A[2][2] * A[4][1]
    A3423 = A[2][3] * A[3][4] - A[2][4] * A[3][3]
    A2423 = A[2][2] * A[3][4] - A[2][4] * A[3][2]
    A2323 = A[2][2] * A[3][3] - A[2][3] * A[3][2]
    A1423 = A[2][1] * A[3][4] - A[2][4] * A[3][1]
    A1323 = A[2][1] * A[3][3] - A[2][3] * A[3][1]
    A1223 = A[2][1] * A[3][2] - A[2][2] * A[3][1]
    A0424 = A[2][0] * A[4][4] - A[2][4] * A[4][0]
    A0324 = A[2][0] * A[4][3] - A[2][3] * A[4][0]
    A0224 = A[2][0] * A[4][2] - A[2][2] * A[4][0]
    A0423 = A[2][0] * A[3][4] - A[2][4] * A[3][0]
    A0323 = A[2][0] * A[3][3] - A[2][3] * A[3][0]
    A0223 = A[2][0] * A[3][2] - A[2][2] * A[3][0]
    A0124 = A[2][0] * A[4][1] - A[2][1] * A[4][0]
    A0123 = A[2][0] * A[3][1] - A[2][1] * A[3][0]
    B234234 = A[2][2] * A3434 - A[2][3] * A2434 + A[2][4] * A2334
    B134234 = A[2][1] * A3434 - A[2][3] * A1434 + A[2][4] * A1334
    B124234 = A[2][1] * A2434 - A[2][2] * A1434 + A[2][4] * A1234
    B123234 = A[2][1] * A2334 - A[2][2] * A1334 + A[2][3] * A1234
    B034234 = A[2][0] * A3434 - A[2][3] * A0434 + A[2][4] * A0334
    B024234 = A[2][0] * A2434 - A[2][2] * A0434 + A[2][4] * A0234
    B023234 = A[2][0] * A2334 - A[2][2] * A0334 + A[2][3] * A0234
    B014234 = A[2][0] * A1434 - A[2][1] * A0434 + A[2][4] * A0134
    B013234 = A[2][0] * A1334 - A[2][1] * A0334 + A[2][3] * A0134
    B012234 = A[2][0] * A1234 - A[2][1] * A0234 + A[2][2] * A0134
    B234134 = A[1][2] * A3434 - A[1][3] * A2434 + A[1][4] * A2334
    B134134 = A[1][1] * A3434 - A[1][3] * A1434 + A[1][4] * A1334
    B124134 = A[1][1] * A2434 - A[1][2] * A1434 + A[1][4] * A1234
    B123134 = A[1][1] * A2334 - A[1][2] * A1334 + A[1][3] * A1234
    B234124 = A[1][2] * A3424 - A[1][3] * A2424 + A[1][4] * A2324
    B134124 = A[1][1] * A3424 - A[1][3] * A1424 + A[1][4] * A1324
    B124124 = A[1][1] * A2424 - A[1][2] * A1424 + A[1][4] * A1224
    B123124 = A[1][1] * A2324 - A[1][2] * A1324 + A[1][3] * A1224
    B234123 = A[1][2] * A3423 - A[1][3] * A2423 + A[1][4] * A2323
    B134123 = A[1][1] * A3423 - A[1][3] * A1423 + A[1][4] * A1323
    B124123 = A[1][1] * A2423 - A[1][2] * A1423 + A[1][4] * A1223
    B123123 = A[1][1] * A2323 - A[1][2] * A1323 + A[1][3] * A1223
    B034134 = A[1][0] * A3434 - A[1][3] * A0434 + A[1][4] * A0334
    B024134 = A[1][0] * A2434 - A[1][2] * A0434 + A[1][4] * A0234
    B023134 = A[1][0] * A2334 - A[1][2] * A0334 + A[1][3] * A0234
    B034124 = A[1][0] * A3424 - A[1][3] * A0424 + A[1][4] * A0324
    B024124 = A[1][0] * A2424 - A[1][2] * A0424 + A[1][4] * A0224
    B023124 = A[1][0] * A2324 - A[1][2] * A0324 + A[1][3] * A0224
    B034123 = A[1][0] * A3423 - A[1][3] * A0423 + A[1][4] * A0323
    B024123 = A[1][0] * A2423 - A[1][2] * A0423 + A[1][4] * A0223
    B023123 = A[1][0] * A2323 - A[1][2] * A0323 + A[1][3] * A0223
    B014134 = A[1][0] * A1434 - A[1][1] * A0434 + A[1][4] * A0134
    B013134 = A[1][0] * A1334 - A[1][1] * A0334 + A[1][3] * A0134
    B014124 = A[1][0] * A1424 - A[1][1] * A0424 + A[1][4] * A0124
    B013124 = A[1][0] * A1324 - A[1][1] * A0324 + A[1][3] * A0124
    B014123 = A[1][0] * A1423 - A[1][1] * A0423 + A[1][4] * A0123
    B013123 = A[1][0] * A1323 - A[1][1] * A0323 + A[1][3] * A0123
    B012134 = A[1][0] * A1234 - A[1][1] * A0234 + A[1][2] * A0134
    B012124 = A[1][0] * A1224 - A[1][1] * A0224 + A[1][2] * A0124
    B012123 = A[1][0] * A1223 - A[1][1] * A0223 + A[1][2] * A0123
    det = A[0][0]*(A[1][1]*B234234-A[1][2]*B134234+A[1][3]*B124234-A[1][4]*B123234) - A[0][1]*(A[1][0]*B234234-A[1][2]*B034234+A[1][3]*B024234-A[1][4]*B023234) + A[0][2]*(A[1][0]*B134234-A[1][1]*B034234+A[1][3]*B014234-A[1][4]*B013234) - A[0][3]*(A[1][0]*B124234-A[1][1]*B024234+A[1][2]*B014234-A[1][4]*B012234) + A[0][4]*(A[1][0]*B123234-A[1][1]*B023234+A[1][2]*B013234-A[1][3]*B012234)
    det = 1.0/det
    Ainv[0][0] = det *   ( A[1][1] * B234234 - A[1][2] * B134234 + A[1][3] * B124234 - A[1][4] * B123234 )
    Ainv[0][1] = det * - ( A[0][1] * B234234 - A[0][2] * B134234 + A[0][3] * B124234 - A[0][4] * B123234 )
    Ainv[0][2] = det *   ( A[0][1] * B234134 - A[0][2] * B134134 + A[0][3] * B124134 - A[0][4] * B123134 )
    Ainv[0][3] = det * - ( A[0][1] * B234124 - A[0][2] * B134124 + A[0][3] * B124124 - A[0][4] * B123124 )
    Ainv[0][4] = det *   ( A[0][1] * B234123 - A[0][2] * B134123 + A[0][3] * B124123 - A[0][4] * B123123 )
    Ainv[1][0] = det * - ( A[1][0] * B234234 - A[1][2] * B034234 + A[1][3] * B024234 - A[1][4] * B023234 )
    Ainv[1][1] = det *   ( A[0][0] * B234234 - A[0][2] * B034234 + A[0][3] * B024234 - A[0][4] * B023234 )
    Ainv[1][2] = det * - ( A[0][0] * B234134 - A[0][2] * B034134 + A[0][3] * B024134 - A[0][4] * B023134 )
    Ainv[1][3] = det *   ( A[0][0] * B234124 - A[0][2] * B034124 + A[0][3] * B024124 - A[0][4] * B023124 )
    Ainv[1][4] = det * - ( A[0][0] * B234123 - A[0][2] * B034123 + A[0][3] * B024123 - A[0][4] * B023123 )
    Ainv[2][0] = det *   ( A[1][0] * B134234 - A[1][1] * B034234 + A[1][3] * B014234 - A[1][4] * B013234 )
    Ainv[2][1] = det * - ( A[0][0] * B134234 - A[0][1] * B034234 + A[0][3] * B014234 - A[0][4] * B013234 )
    Ainv[2][2] = det *   ( A[0][0] * B134134 - A[0][1] * B034134 + A[0][3] * B014134 - A[0][4] * B013134 )
    Ainv[2][3] = det * - ( A[0][0] * B134124 - A[0][1] * B034124 + A[0][3] * B014124 - A[0][4] * B013124 )
    Ainv[2][4] = det *   ( A[0][0] * B134123 - A[0][1] * B034123 + A[0][3] * B014123 - A[0][4] * B013123 )
    Ainv[3][0] = det * - ( A[1][0] * B124234 - A[1][1] * B024234 + A[1][2] * B014234 - A[1][4] * B012234 )
    Ainv[3][1] = det *   ( A[0][0] * B124234 - A[0][1] * B024234 + A[0][2] * B014234 - A[0][4] * B012234 )
    Ainv[3][2] = det * - ( A[0][0] * B124134 - A[0][1] * B024134 + A[0][2] * B014134 - A[0][4] * B012134 )
    Ainv[3][3] = det *   ( A[0][0] * B124124 - A[0][1] * B024124 + A[0][2] * B014124 - A[0][4] * B012124 )
    Ainv[3][4] = det * - ( A[0][0] * B124123 - A[0][1] * B024123 + A[0][2] * B014123 - A[0][4] * B012123 )
    Ainv[4][0] = det *   ( A[1][0] * B123234 - A[1][1] * B023234 + A[1][2] * B013234 - A[1][3] * B012234 )
    Ainv[4][1] = det * - ( A[0][0] * B123234 - A[0][1] * B023234 + A[0][2] * B013234 - A[0][3] * B012234 )
    Ainv[4][2] = det *   ( A[0][0] * B123134 - A[0][1] * B023134 + A[0][2] * B013134 - A[0][3] * B012134 )
    Ainv[4][3] = det * - ( A[0][0] * B123124 - A[0][1] * B023124 + A[0][2] * B013124 - A[0][3] * B012124 )
    Ainv[4][4] = det *   ( A[0][0] * B123123 - A[0][1] * B023123 + A[0][2] * B013123 - A[0][3] * B012123 )
    return

cdef void update_sinv(double [:] data, long long [:] row_ind, long long [:] col_ptr, double [:,::1] Q, double [:,::1] T, long long cnum, long long qsize):
    cdef long long k1
    cdef long long k2
    cdef long long r
    cdef long long c
    cdef long long ptr
    cdef double tQt
    cdef double *Tr
    cdef double *Tc
    cdef double *Qt
    with nogil, parallel():
        Tr = <double*> malloc(qsize*sizeof(double))
        Tc = <double*> malloc(qsize*sizeof(double))
        Qt = <double*> malloc(qsize*sizeof(double))
        for c in prange(cnum,schedule='static'):
            for k1 in range(qsize):
                Tc[k1] = T[c,k1]
            for k1 in range(qsize):
                Qt[k1] = 0.0
                for k2 in range(qsize):
                    Qt[k1] = Qt[k1] + Q[k1][k2] * Tc[k2]
            for ptr in range(col_ptr[c],col_ptr[c+1]):
                r = row_ind[ptr]
                for k1 in range(qsize):    
                    Tr[k1] = T[r,k1]
                tQt = 0.0
                for k1 in range(qsize):
                    tQt = tQt + Tr[k1] * Qt[k1]
                data[ptr] = data[ptr] - tQt
        free(Tr)
        free(Tc)
        free(Qt)
    return

cdef void update_sinv_serial(double [:] data, long long [:] row_ind, long long [:] col_ptr, double [:,::1] Q, double [:,::1] T, long long cnum, long long qsize):
    cdef long long k1
    cdef long long k2
    cdef long long r
    cdef long long c
    cdef long long ptr
    cdef double tQt
    cdef double *Tr
    cdef double *Tc
    cdef double *Qt
    Tr = <double*> malloc(qsize*sizeof(double))
    Tc = <double*> malloc(qsize*sizeof(double))
    Qt = <double*> malloc(qsize*sizeof(double))
    for c in range(cnum):
        for k1 in range(qsize):
            Tc[k1] = T[c,k1]
        for k1 in range(qsize):
            Qt[k1] = 0.0
            for k2 in range(qsize):
                Qt[k1] = Qt[k1] + Q[k1][k2] * Tc[k2]
        for ptr in range(col_ptr[c],col_ptr[c+1]):
            r = row_ind[ptr]
            for k1 in range(qsize):    
                Tr[k1] = T[r,k1]
            tQt = 0.0
            for k1 in range(qsize):
                tQt = tQt + Tr[k1] * Qt[k1]
            data[ptr] = data[ptr] - tQt
    free(Tr)
    free(Tc)
    free(Qt)
    return

cdef void ws(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] H, double [:,::1] H_01, double [:,::1] H_67, double [:,::1] H_0167, double [:] ur, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k0
    cdef long long k1
    cdef long long k2
    cdef long long k3
    cdef long long r
    cdef long long c
    cdef long long rank
    cdef long long size
    cdef long long bc_var
    cdef double sign
    cdef double sval
    cdef long long *nodes
    cdef long long *freeNodes
    cdef long long *local_ids
    cdef long long *gv
    cdef double *ue
    cdef double *vi
    cdef double *wi
    cdef double **Kinv  
    cdef double **Hg
    cdef double **aux
    cdef double **Ai
    cdef double **Ainv
    bc_var = bc_lim[1] - bc_lim[0] + 1
    N = Nx*Ny
    with nogil, parallel():
        nodes     = <long long*> malloc(4*sizeof(long long))
        freeNodes = <long long*> malloc(4*sizeof(long long))
        local_ids = <long long*> malloc(8*sizeof(long long))
        gv        = <long long*> malloc(8*sizeof(long long))
        ue        = <double*> malloc(8*sizeof(double))
        vi        = <double*> malloc(5*sizeof(double))
        wi        = <double*> malloc(5*sizeof(double))
        Kinv      = <double**> malloc(8*sizeof(double *))
        Hg        = <double**> malloc(8*sizeof(double *))
        aux       = <double**> malloc(8*sizeof(double *))
        Ai        = <double**> malloc(5*sizeof(double *))
        Ainv      = <double**> malloc(5*sizeof(double *))
        for k0 in range(8):
            Kinv[k0] = <double*> malloc(8*sizeof(double))
            Hg[k0]   = <double*> malloc(5*sizeof(double))
            aux[k0]  = <double*> malloc(5*sizeof(double))
        for k0 in range(5):
            Ai[k0]   = <double*> malloc(5*sizeof(double))
            Ainv[k0] = <double*> malloc(5*sizeof(double))
        for e in prange(N,schedule='static'):
            sign = 1.0 - 2.0*dens[e]
            nodes[0] = e + e//Ny
            nodes[1] = nodes[0] + 1
            nodes[2] = nodes[0] + 1 + Ny
            nodes[3] = nodes[2] + 1
            for k1 in range(4):
                if (nodes[k1] < bc_lim[0]) or (nodes[k1] > bc_lim[1]):
                    freeNodes[k1] = 1
                    if nodes[k1] > bc_lim[1]:
                        nodes[k1] = nodes[k1] - bc_var
                else:
                    freeNodes[k1] = 0     
            if (freeNodes[0]==1) and (freeNodes[1]==1):
                size = 8
                rank = 5
                for k1 in range(size):
                    for k2 in range(rank):
                        Hg[k1][k2] = H[k1][k2]
                for k1 in range(4):
                    gv[2*k1]   = 2*nodes[k1]
                    gv[2*k1+1] = 2*nodes[k1] + 1
                local_ids[0] = 0
                local_ids[1] = 1
                local_ids[2] = 6
                local_ids[3] = 7
                local_ids[4] = 2
                local_ids[5] = 3
                local_ids[6] = 4
                local_ids[7] = 5
            elif (freeNodes[0]==0) and (freeNodes[1]==1):
                size = 6
                rank = 5
                for k1 in range(size):
                    for k2 in range(rank):
                        Hg[k1][k2] = H_01[k1][k2]
                k2 = 0
                for k1 in range(4):
                    if (freeNodes[k1]==1):
                        gv[2*k2]   = 2*nodes[k1]
                        gv[2*k2+1] = 2*nodes[k1] + 1
                        k2 = k2 + 1            
                local_ids[0] = 4
                local_ids[1] = 5
                local_ids[2] = 0
                local_ids[3] = 1
                local_ids[4] = 2
                local_ids[5] = 3
            elif (freeNodes[0]==1) and (freeNodes[1]==0):
                size = 6
                rank = 5
                for k1 in range(size):
                    for k2 in range(rank):
                        Hg[k1][k2] = H_67[k1][k2]
                k2 = 0
                for k1 in range(4):
                    if (freeNodes[k1]==1):
                        gv[2*k2]   = 2*nodes[k1]
                        gv[2*k2+1] = 2*nodes[k1] + 1
                        k2 = k2 + 1
                local_ids[0] = 0
                local_ids[1] = 1
                local_ids[2] = 2
                local_ids[3] = 3
                local_ids[4] = 4
                local_ids[5] = 5
            else:
                size = 4
                rank = 4
                for k1 in range(size):
                    for k2 in range(rank):
                        Hg[k1][k2] = H_0167[k1][k2]
                k2 = 0
                for k1 in range(4):
                    if (freeNodes[k1]==1):
                        gv[2*k2]   = 2*nodes[k1]
                        gv[2*k2+1] = 2*nodes[k1] + 1
                        k2 = k2 + 1
                local_ids[0] = 0
                local_ids[1] = 1
                local_ids[2] = 2
                local_ids[3] = 3
            for k1 in range(size):
                ue[local_ids[k1]] = ur[gv[k1]]
            for c in range(size):
                r = c
                for k1 in range(col_ptr[gv[c]]+c,col_ptr[gv[c]+1]):    
                    if row_ind[k1] == gv[r]:
                        Kinv[local_ids[r]][local_ids[c]] = data[k1]
                        Kinv[local_ids[c]][local_ids[r]] = data[k1]
                        if r == size-1:
                            break
                        else:
                            r = r + 1
            for k1 in range(size):
                for k2 in range(rank):
                    aux[k1][k2] = 0.0
                    for k3 in range(size):
                        aux[k1][k2] = aux[k1][k2] + Kinv[k1][k3] * Hg[k3][k2]
            for k1 in range(rank):
                Ai[k1][k1] = 0.0
                vi[k1] = 0.0
                for k3 in range(size):
                    Ai[k1][k1] = Ai[k1][k1] + Hg[k3][k1] * aux[k3][k1]
                    vi[k1] = vi[k1] + Hg[k3][k1] * ue[k3]
                for k2 in range(k1+1,rank):
                    Ai[k1][k2] = 0.0
                    Ai[k2][k1] = 0.0
                    for k3 in range(size):
                        Ai[k1][k2] = Ai[k1][k2] + Hg[k3][k1] * aux[k3][k2]
                        Ai[k2][k1] = Ai[k2][k1] + Hg[k3][k2] * aux[k3][k1]
                    Ai[k1][k2] = 0.5*(Ai[k1][k2] + Ai[k2][k1])
                    Ai[k2][k1] = Ai[k1][k2]
            sval = 0.0
            for k1 in range(rank):
                Ai[k1][k1] = Ai[k1][k1] + sign
            if rank == 4:
                inv_4x4(Ai,Ainv)
            else:  # rank = 5
                inv_5x5(Ai,Ainv)
            for k1 in range(rank):
                wi[k1] = 0.0
                for k2 in range(rank):
                    wi[k1] = wi[k1] + Ainv[k1][k2] * vi[k2]
                sval = sval - sign * vi[k1] * wi[k1]
            alpha_r[e] = sval
        free(nodes)
        free(freeNodes)
        free(local_ids)
        free(ue)
        free(vi)
        free(wi)
        for k0 in range(8):
            free(Kinv[k0])
            free(Hg[k0])
            free(aux[k0])
        for k0 in range(5):
            free(Ai[k0])
            free(Ainv[k0])
        free(Kinv)
        free(Hg)
        free(aux)
        free(Ai)
        free(Ainv)
    return

cdef void ws_serial(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] H, double [:,::1] H_01, double [:,::1] H_67, double [:,::1] H_0167, double [:] ur, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k0
    cdef long long k1
    cdef long long k2
    cdef long long k3
    cdef long long r
    cdef long long c
    cdef long long rank
    cdef long long size
    cdef long long bc_var
    cdef double sign
    cdef double sval
    cdef long long nodes[4]
    cdef long long freeNodes[4]
    cdef long long local_ids[8]
    cdef long long gv[8]
    cdef double ue[8]
    cdef double vi[5]
    cdef double wi[5]
    cdef double Kinv[8][8]    
    cdef double Hg[8][5]
    cdef double aux[8][5]
    cdef double **Ai
    cdef double **Ainv
    Ai   = <double**> malloc(5*sizeof(double *))
    Ainv = <double**> malloc(5*sizeof(double *))
    for k0 in range(5):
        Ai[k0]   = <double*> malloc(5*sizeof(double))
        Ainv[k0] = <double*> malloc(5*sizeof(double))
    bc_var = bc_lim[1] - bc_lim[0] + 1
    N = Nx*Ny
    for e in range(N):
        sign = 1.0 - 2.0*dens[e]
        nodes[0] = e + e//Ny
        nodes[1] = nodes[0] + 1
        nodes[2] = nodes[0] + 1 + Ny
        nodes[3] = nodes[2] + 1
        for k1 in range(4):
            if (nodes[k1] < bc_lim[0]) or (nodes[k1] > bc_lim[1]):
                freeNodes[k1] = 1
                if nodes[k1] > bc_lim[1]:
                    nodes[k1] = nodes[k1] - bc_var
            else:
                freeNodes[k1] = 0     
        if (freeNodes[0]==1) and (freeNodes[1]==1):
            size = 8
            rank = 5
            for k1 in range(size):
                for k2 in range(rank):
                    Hg[k1][k2] = H[k1][k2]
            for k1 in range(4):
                gv[2*k1]   = 2*nodes[k1]
                gv[2*k1+1] = 2*nodes[k1] + 1
            local_ids[0] = 0
            local_ids[1] = 1
            local_ids[2] = 6
            local_ids[3] = 7
            local_ids[4] = 2
            local_ids[5] = 3
            local_ids[6] = 4
            local_ids[7] = 5
        elif (freeNodes[0]==0) and (freeNodes[1]==1):
            size = 6
            rank = 5
            for k1 in range(size):
                for k2 in range(rank):
                    Hg[k1][k2] = H_01[k1][k2]
            k2 = 0
            for k1 in range(4):
                if (freeNodes[k1]==1):
                    gv[2*k2]   = 2*nodes[k1]
                    gv[2*k2+1] = 2*nodes[k1] + 1
                    k2 = k2 + 1            
            local_ids[0] = 4
            local_ids[1] = 5
            local_ids[2] = 0
            local_ids[3] = 1
            local_ids[4] = 2
            local_ids[5] = 3
        elif (freeNodes[0]==1) and (freeNodes[1]==0):
            size = 6
            rank = 5
            for k1 in range(size):
                for k2 in range(rank):
                    Hg[k1][k2] = H_67[k1][k2]
            k2 = 0
            for k1 in range(4):
                if (freeNodes[k1]==1):
                    gv[2*k2]   = 2*nodes[k1]
                    gv[2*k2+1] = 2*nodes[k1] + 1
                    k2 = k2 + 1
            local_ids[0] = 0
            local_ids[1] = 1
            local_ids[2] = 2
            local_ids[3] = 3
            local_ids[4] = 4
            local_ids[5] = 5
        else:
            size = 4
            rank = 4
            for k1 in range(size):
                for k2 in range(rank):
                    Hg[k1][k2] = H_0167[k1][k2]
            k2 = 0
            for k1 in range(4):
                if (freeNodes[k1]==1):
                    gv[2*k2]   = 2*nodes[k1]
                    gv[2*k2+1] = 2*nodes[k1] + 1
                    k2 = k2 + 1
            local_ids[0] = 0
            local_ids[1] = 1
            local_ids[2] = 2
            local_ids[3] = 3
        for k1 in range(size):
            ue[local_ids[k1]] = ur[gv[k1]]
        for c in range(size):
            r = c
            for k1 in range(col_ptr[gv[c]]+c,col_ptr[gv[c]+1]):    
                if row_ind[k1] == gv[r]:
                    Kinv[local_ids[r]][local_ids[c]] = data[k1]
                    Kinv[local_ids[c]][local_ids[r]] = data[k1]
                    if r == size-1:
                        break
                    else:
                        r = r + 1
        for k1 in range(size):
            for k2 in range(rank):
                aux[k1][k2] = 0.0
                for k3 in range(size):
                    aux[k1][k2] = aux[k1][k2] + Kinv[k1][k3] * Hg[k3][k2]
        for k1 in range(rank):
            Ai[k1][k1] = 0.0
            vi[k1] = 0.0
            for k3 in range(size):
                Ai[k1][k1] = Ai[k1][k1] + Hg[k3][k1] * aux[k3][k1]
                vi[k1] = vi[k1] + Hg[k3][k1] * ue[k3]
            for k2 in range(k1+1,rank):
                Ai[k1][k2] = 0.0
                Ai[k2][k1] = 0.0
                for k3 in range(size):
                    Ai[k1][k2] = Ai[k1][k2] + Hg[k3][k1] * aux[k3][k2]
                    Ai[k2][k1] = Ai[k2][k1] + Hg[k3][k2] * aux[k3][k1]
                Ai[k1][k2] = 0.5*(Ai[k1][k2] + Ai[k2][k1])
                Ai[k2][k1] = Ai[k1][k2]
        sval = 0.0
        for k1 in range(rank):
            Ai[k1][k1] = Ai[k1][k1] + sign
        if rank == 4:
            inv_4x4(Ai,Ainv)
        else:  # rank = 5
            inv_5x5(Ai,Ainv)
        for k1 in range(rank):
            wi[k1] = 0.0
            for k2 in range(rank):
                wi[k1] = wi[k1] + Ainv[k1][k2] * vi[k2]
            sval = sval - sign * vi[k1] * wi[k1]
        alpha_r[e] = sval
    for k0 in range(5):
        free(Ai[k0])
        free(Ainv[k0])
    free(Ai)
    free(Ainv)
    return

cdef void cgs_0(double [:] alpha_r, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k1
    cdef long long k2
    cdef double sval
    cdef long long *nodes
    cdef long long *dofs
    cdef double *ue
    cdef double *fe
    N = Nx*Ny
    with nogil, parallel():
        nodes = <long long*> malloc(4*sizeof(long long))
        dofs  = <long long*> malloc(8*sizeof(long long))
        ue    = <double*> malloc(8*sizeof(double))
        fe    = <double*> malloc(8*sizeof(double))
        for e in prange(N,schedule='static'):
            nodes[0] = e + e//Ny
            nodes[1] = nodes[0] + 1 + Ny
            nodes[2] = nodes[1] + 1
            nodes[3] = nodes[0] + 1
            for k1 in range(4):
                dofs[2*k1] = 2*nodes[k1]
                dofs[2*k1+1] = dofs[2*k1] + 1
            for k1 in range(8):
                ue[k1] = ug[dofs[k1]]
            sval = 0.0
            for k1 in range(8):
                fe[k1] = 0.0
                for k2 in range(8):
                    fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2] 
                sval = sval - ue[k1]*fe[k1]
            alpha_r[e] = sval
        free(nodes)
        free(dofs)
        free(ue)
        free(fe)
    return

cdef void cgs_0_serial(double [:] alpha_r, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k1
    cdef long long k2
    cdef double sval
    cdef long long nodes[4]
    cdef long long dofs[8]
    cdef double ue[8]
    cdef double fe[8]
    N = Nx*Ny
    for e in range(N):
        nodes[0] = e + e//Ny
        nodes[1] = nodes[0] + 1 + Ny
        nodes[2] = nodes[1] + 1
        nodes[3] = nodes[0] + 1
        for k1 in range(4):
            dofs[2*k1] = 2*nodes[k1]
            dofs[2*k1+1] = dofs[2*k1] + 1
        for k1 in range(8):
            ue[k1] = ug[dofs[k1]]
        sval = 0.0
        for k1 in range(8):
            fe[k1] = 0.0
            for k2 in range(8):
                fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2] 
            sval = sval - ue[k1]*fe[k1]
        alpha_r[e] = sval
    return

cdef void cgs_1I(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k0
    cdef long long k1
    cdef long long k2
    cdef long long c
    cdef long long r
    cdef long long col
    cdef double b0
    cdef double b1
    cdef double sval
    cdef long long *nodes
    cdef long long *dofs
    cdef long long *local_ids
    cdef double *ue
    cdef double *fe
    cdef double *ffe
    cdef double **Kbb
    N = Nx*Ny
    with nogil, parallel():
        nodes     = <long long*> malloc(4*sizeof(long long))
        dofs      = <long long*> malloc(8*sizeof(long long))
        local_ids = <long long*> malloc(8*sizeof(long long))
        ue        = <double*> malloc(8*sizeof(double))
        fe        = <double*> malloc(8*sizeof(double))
        ffe       = <double*> malloc(8*sizeof(double))
        Kbb       = <double**> malloc(8*sizeof(double *))
        for k0 in range(8):
            Kbb[k0] = <double*> malloc(8*sizeof(double))
        for e in prange(N,schedule='static'):
            col = e // Ny
            nodes[0] = e + col
            nodes[1] = nodes[0] + 1
            nodes[2] = nodes[0] + 1 + Ny
            nodes[3] = nodes[2] + 1
            for k1 in range(4):
                dofs[2*k1] = 2*nodes[k1]
                dofs[2*k1+1] = dofs[2*k1] + 1
            local_ids[0] = 0
            local_ids[1] = 1
            local_ids[2] = 6
            local_ids[3] = 7
            local_ids[4] = 2
            local_ids[5] = 3
            local_ids[6] = 4
            local_ids[7] = 5
            for k1 in range(8):
                ue[local_ids[k1]] = ug[dofs[k1]]
            sval = 0.0
            for k1 in range(8):
                ffe[k1] = 0.0    
                fe[k1] = 0.0
                for k2 in range(8):
                    fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
                sval = sval - ue[k1]*fe[k1]
            # cantilever constraints
            if col == 0:
                if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                    fe[0] = 0.0
                    fe[1] = 0.0
                if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                    fe[6] = 0.0
                    fe[7] = 0.0
            b0 = 0.0
            for k1 in range(8):
                b0 = b0 + fe[k1]*fe[k1]
            for c in range(8):
                r = c
                for k1 in range(col_ptr[dofs[c]]+c,col_ptr[dofs[c]+1]):
                    if row_ind[k1] == dofs[r]:
                        Kbb[local_ids[r]][local_ids[c]] = data[k1]
                        Kbb[local_ids[c]][local_ids[r]] = data[k1]
                        if r == 7:
                            break
                        else:
                            r = r + 1
            b1 = 0.0
            if dens[e] == 0:
                for k1 in range(8):
                    Kbb[k1][k1] = Kbb[k1][k1] + dKe[k1][k1]
                    ffe[k1] = ffe[k1] + Kbb[k1][k1]*fe[k1]
                    for k2 in range(k1+1,8):
                        Kbb[k1][k2] = Kbb[k1][k2] + dKe[k1][k2]
                        Kbb[k2][k1] = Kbb[k1][k2]
                        ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
                        ffe[k2] = ffe[k2] + Kbb[k2][k1]*fe[k1]
                    b1 = b1 + fe[k1]*ffe[k1]
                sval = sval + (b0*b0)/b1
            else:
                for k1 in range(8):
                    Kbb[k1][k1] = Kbb[k1][k1] - dKe[k1][k1]
                    ffe[k1] = ffe[k1] + Kbb[k1][k1]*fe[k1]
                    for k2 in range(k1+1,8):
                        Kbb[k1][k2] = Kbb[k1][k2] - dKe[k1][k2]
                        Kbb[k2][k1] = Kbb[k1][k2]
                        ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
                        ffe[k2] = ffe[k2] + Kbb[k2][k1]*fe[k1]
                    b1 = b1 + fe[k1]*ffe[k1]
                sval = sval - (b0*b0)/b1
            alpha_r[e] = sval
        free(nodes)
        free(dofs)
        free(local_ids)
        free(ue)
        free(fe)
        free(ffe)
        for k0 in range(8):
            free(Kbb[k0])
        free(Kbb)
    return

cdef void cgs_1I_serial(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k1
    cdef long long k2
    cdef long long c
    cdef long long r
    cdef long long col
    cdef double b0
    cdef double b1
    cdef double sval
    cdef long long nodes[4]
    cdef long long dofs[8]
    cdef long long local_ids[8]
    cdef double ue[8]
    cdef double fe[8]
    cdef double ffe[8]
    cdef double Kbb[8][8]
    N = Nx*Ny
    for e in range(N):
        col = e // Ny
        nodes[0] = e + col
        nodes[1] = nodes[0] + 1
        nodes[2] = nodes[0] + 1 + Ny
        nodes[3] = nodes[2] + 1
        for k1 in range(4):
            dofs[2*k1] = 2*nodes[k1]
            dofs[2*k1+1] = dofs[2*k1] + 1
        local_ids[0] = 0
        local_ids[1] = 1
        local_ids[2] = 6
        local_ids[3] = 7
        local_ids[4] = 2
        local_ids[5] = 3
        local_ids[6] = 4
        local_ids[7] = 5
        for k1 in range(8):
            ue[local_ids[k1]] = ug[dofs[k1]]
        sval = 0.0
        for k1 in range(8):
            ffe[k1] = 0.0    
            fe[k1] = 0.0
            for k2 in range(8):
                fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
            sval = sval - ue[k1]*fe[k1]
        # cantilever constraints
        if col == 0:
            if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                fe[0] = 0.0
                fe[1] = 0.0
            if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                fe[6] = 0.0
                fe[7] = 0.0
        b0 = 0.0
        for k1 in range(8):
            b0 = b0 + fe[k1]*fe[k1]
        for c in range(8):
            r = c
            for k1 in range(col_ptr[dofs[c]]+c,col_ptr[dofs[c]+1]):
                if row_ind[k1] == dofs[r]:
                    Kbb[local_ids[r]][local_ids[c]] = data[k1]
                    Kbb[local_ids[c]][local_ids[r]] = data[k1]
                    if r == 7:
                        break
                    else:
                        r = r + 1
        b1 = 0.0
        if dens[e] == 0:
            for k1 in range(8):
                Kbb[k1][k1] = Kbb[k1][k1] + dKe[k1][k1]
                ffe[k1] = ffe[k1] + Kbb[k1][k1]*fe[k1]
                for k2 in range(k1+1,8):
                    Kbb[k1][k2] = Kbb[k1][k2] + dKe[k1][k2]
                    Kbb[k2][k1] = Kbb[k1][k2]
                    ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
                    ffe[k2] = ffe[k2] + Kbb[k2][k1]*fe[k1]
                b1 = b1 + fe[k1]*ffe[k1]
            sval = sval + (b0*b0)/b1
        else:
            for k1 in range(8):
                Kbb[k1][k1] = Kbb[k1][k1] - dKe[k1][k1]
                ffe[k1] = ffe[k1] + Kbb[k1][k1]*fe[k1]
                for k2 in range(k1+1,8):
                    Kbb[k1][k2] = Kbb[k1][k2] - dKe[k1][k2]
                    Kbb[k2][k1] = Kbb[k1][k2]
                    ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
                    ffe[k2] = ffe[k2] + Kbb[k2][k1]*fe[k1]
                b1 = b1 + fe[k1]*ffe[k1]
            sval = sval - (b0*b0)/b1
        alpha_r[e] = sval
    return

cdef void cgs_1J(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k0
    cdef long long k1
    cdef long long k2
    cdef long long c
    cdef long long r
    cdef long long col
    cdef double b0
    cdef double b1
    cdef double sval
    cdef long long *nodes
    cdef long long *dofs
    cdef long long *local_ids
    cdef double *ue
    cdef double *fe
    cdef double *mfe
    cdef double *ffe
    cdef double **Kbb
    N = Nx*Ny
    with nogil, parallel():
        nodes     = <long long*> malloc(4*sizeof(long long))
        dofs      = <long long*> malloc(8*sizeof(long long))
        local_ids = <long long*> malloc(8*sizeof(long long))
        ue        = <double*> malloc(8*sizeof(double))
        fe        = <double*> malloc(8*sizeof(double))
        mfe       = <double*> malloc(8*sizeof(double))
        ffe       = <double*> malloc(8*sizeof(double))
        Kbb       = <double**> malloc(8*sizeof(double *))
        for k0 in range(8):
            Kbb[k0] = <double*> malloc(8*sizeof(double))
        for e in prange(N,schedule='static'): 
            col = e // Ny
            nodes[0] = e + col
            nodes[1] = nodes[0] + 1
            nodes[2] = nodes[0] + 1 + Ny
            nodes[3] = nodes[2] + 1
            for k1 in range(4):
                dofs[2*k1] = 2*nodes[k1]
                dofs[2*k1+1] = dofs[2*k1] + 1
            local_ids[0] = 0
            local_ids[1] = 1
            local_ids[2] = 6
            local_ids[3] = 7
            local_ids[4] = 2
            local_ids[5] = 3
            local_ids[6] = 4
            local_ids[7] = 5
            for k1 in range(8):
                ue[local_ids[k1]] = ug[dofs[k1]]
            sval = 0.0
            for k1 in range(8):
                ffe[k1] = 0.0    
                fe[k1] = 0.0
                for k2 in range(8):
                    fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
                sval = sval - ue[k1]*fe[k1]
            # cantilever constraints
            if col == 0:
                if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                    fe[0] = 0.0
                    fe[1] = 0.0
                if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                    fe[6] = 0.0
                    fe[7] = 0.0
            for c in range(8):
                r = c
                for k1 in range(col_ptr[dofs[c]]+c,col_ptr[dofs[c]+1]):
                    if row_ind[k1] == dofs[r]:
                        Kbb[local_ids[r]][local_ids[c]] = data[k1]
                        Kbb[local_ids[c]][local_ids[r]] = data[k1]
                        if r == 7:
                            break
                        else:
                            r = r + 1
            b0 = 0.0
            b1 = 0.0
            if dens[e] == 0:
                for k1 in range(8):
                    Kbb[k1][k1] = Kbb[k1][k1] + dKe[k1][k1]
                    mfe[k1] = fe[k1]/Kbb[k1][k1]
                    for k2 in range(k1+1,8):
                        Kbb[k1][k2] = Kbb[k1][k2] + dKe[k1][k2]
                        Kbb[k2][k1] = Kbb[k1][k2]
                    b0 = b0 + fe[k1]*mfe[k1]
                for k1 in range(8):
                    ffe[k1] = ffe[k1] + Kbb[k1][k1]*mfe[k1]
                    for k2 in range(k1+1,8):
                        ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
                        ffe[k2] = ffe[k2] + Kbb[k2][k1]*mfe[k1]
                    b1 = b1 + mfe[k1]*ffe[k1]
                sval = sval + (b0*b0)/b1
            else:
                for k1 in range(8):
                    Kbb[k1][k1] = Kbb[k1][k1] - dKe[k1][k1]
                    mfe[k1] = fe[k1]/Kbb[k1][k1]
                    for k2 in range(k1+1,8):
                        Kbb[k1][k2] = Kbb[k1][k2] - dKe[k1][k2]
                        Kbb[k2][k1] = Kbb[k1][k2]
                    b0 = b0 + fe[k1]*mfe[k1]
                for k1 in range(8):
                    ffe[k1] = ffe[k1] + Kbb[k1][k1]*mfe[k1]
                    for k2 in range(k1+1,8):
                        ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
                        ffe[k2] = ffe[k2] + Kbb[k2][k1]*mfe[k1]
                    b1 = b1 + mfe[k1]*ffe[k1]
                sval = sval - (b0*b0)/b1
            alpha_r[e] = sval
        free(nodes)
        free(dofs)
        free(local_ids)
        free(ue)
        free(fe)
        free(mfe)
        free(ffe)
        for k0 in range(8):
            free(Kbb[k0])
        free(Kbb)
    return

cdef void cgs_1J_serial(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k1
    cdef long long k2
    cdef long long c
    cdef long long r
    cdef long long col
    cdef double b0
    cdef double b1
    cdef double sval
    cdef long long nodes[4]
    cdef long long dofs[8]
    cdef long long local_ids[8]
    cdef double ue[8]
    cdef double fe[8]
    cdef double mfe[8]
    cdef double ffe[8]
    cdef double Kbb[8][8]
    N = Nx*Ny
    for e in range(N): 
        col = e // Ny
        nodes[0] = e + col
        nodes[1] = nodes[0] + 1
        nodes[2] = nodes[0] + 1 + Ny
        nodes[3] = nodes[2] + 1
        for k1 in range(4):
            dofs[2*k1] = 2*nodes[k1]
            dofs[2*k1+1] = dofs[2*k1] + 1
        local_ids[0] = 0
        local_ids[1] = 1
        local_ids[2] = 6
        local_ids[3] = 7
        local_ids[4] = 2
        local_ids[5] = 3
        local_ids[6] = 4
        local_ids[7] = 5
        for k1 in range(8):
            ue[local_ids[k1]] = ug[dofs[k1]]
        sval = 0.0
        for k1 in range(8):
            ffe[k1] = 0.0    
            fe[k1] = 0.0
            for k2 in range(8):
                fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
            sval = sval - ue[k1]*fe[k1]
        # cantilever constraints
        if col == 0:
            if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                fe[0] = 0.0
                fe[1] = 0.0
            if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                fe[6] = 0.0
                fe[7] = 0.0
        for c in range(8):
            r = c
            for k1 in range(col_ptr[dofs[c]]+c,col_ptr[dofs[c]+1]):
                if row_ind[k1] == dofs[r]:
                    Kbb[local_ids[r]][local_ids[c]] = data[k1]
                    Kbb[local_ids[c]][local_ids[r]] = data[k1]
                    if r == 7:
                        break
                    else:
                        r = r + 1
        b0 = 0.0
        b1 = 0.0
        if dens[e] == 0:
            for k1 in range(8):
                Kbb[k1][k1] = Kbb[k1][k1] + dKe[k1][k1]
                mfe[k1] = fe[k1]/Kbb[k1][k1]
                for k2 in range(k1+1,8):
                    Kbb[k1][k2] = Kbb[k1][k2] + dKe[k1][k2]
                    Kbb[k2][k1] = Kbb[k1][k2]
                b0 = b0 + fe[k1]*mfe[k1]
            for k1 in range(8):
                ffe[k1] = ffe[k1] + Kbb[k1][k1]*mfe[k1]
                for k2 in range(k1+1,8):
                    ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
                    ffe[k2] = ffe[k2] + Kbb[k2][k1]*mfe[k1]
                b1 = b1 + mfe[k1]*ffe[k1]
            sval = sval + (b0*b0)/b1
        else:
            for k1 in range(8):
                Kbb[k1][k1] = Kbb[k1][k1] - dKe[k1][k1]
                mfe[k1] = fe[k1]/Kbb[k1][k1]
                for k2 in range(k1+1,8):
                    Kbb[k1][k2] = Kbb[k1][k2] - dKe[k1][k2]
                    Kbb[k2][k1] = Kbb[k1][k2]
                b0 = b0 + fe[k1]*mfe[k1]
            for k1 in range(8):
                ffe[k1] = ffe[k1] + Kbb[k1][k1]*mfe[k1]
                for k2 in range(k1+1,8):
                    ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
                    ffe[k2] = ffe[k2] + Kbb[k2][k1]*mfe[k1]
                b1 = b1 + mfe[k1]*ffe[k1]
            sval = sval - (b0*b0)/b1
        alpha_r[e] = sval
    return
    
cdef void cgs_2I(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k0
    cdef long long k1
    cdef long long k2
    cdef long long c
    cdef long long r
    cdef long long row
    cdef long long col
    cdef double b0
    cdef double b1
    cdef double b2
    cdef double b3
    cdef double sval
    cdef long long *nodes
    cdef long long *dofs
    cdef long long *local_ids
    cdef double *ue
    cdef double *fe
    cdef double *ffe
    cdef double *fffe
    cdef double **Kbb
    N = Nx*Ny
    with nogil, parallel():
        nodes     = <long long*> malloc(16*sizeof(long long))
        dofs      = <long long*> malloc(32*sizeof(long long))
        local_ids = <long long*> malloc(32*sizeof(long long))
        ue        = <double*> malloc(8*sizeof(double))
        fe        = <double*> malloc(8*sizeof(double))
        ffe       = <double*> malloc(32*sizeof(double))
        fffe      = <double*> malloc(32*sizeof(double))
        Kbb       = <double**> malloc(32*sizeof(double *))
        for k0 in range(32):
            Kbb[k0] = <double*> malloc(32*sizeof(double))
        for e in prange(N,schedule='static'):
            row = e % Ny
            col = e // Ny
            nodes[5]  = e + col
            nodes[0]  = nodes[5] - 2 - Ny
            nodes[1]  = nodes[5] - 1 - Ny
            nodes[2]  = nodes[5] + 0 - Ny
            nodes[3]  = nodes[5] + 1 - Ny
            nodes[4]  = nodes[5] - 1
            nodes[6]  = nodes[5] + 1
            nodes[7]  = nodes[5] + 2
            nodes[8]  = nodes[5] + 0 + Ny
            nodes[9]  = nodes[5] + 1 + Ny
            nodes[10] = nodes[5] + 2 + Ny
            nodes[11] = nodes[5] + 3 + Ny
            nodes[12] = nodes[5] + 1 + Ny*2
            nodes[13] = nodes[5] + 2 + Ny*2
            nodes[14] = nodes[5] + 3 + Ny*2
            nodes[15] = nodes[5] + 4 + Ny*2
            for k1 in range(16):
                dofs[2*k1] = 2*nodes[k1]
                dofs[2*k1+1] = dofs[2*k1] + 1
            if row == 0:
                for k1 in range(4):
                    dofs[8*k1]   = -1
                    dofs[8*k1+1] = -1
            elif row == Ny-1:
                for k1 in range(4):
                    dofs[8*k1+6] = -1
                    dofs[8*k1+7] = -1
            if col == 0:
                for k1 in range(4):
                    dofs[2*k1]   = -1
                    dofs[2*k1+1] = -1
            elif col == Nx-1:
                for k1 in range(4):
                    dofs[2*k1+24] = -1
                    dofs[2*k1+25] = -1
            for k1 in range(10):
                local_ids[k1] = k1+8
            local_ids[10] = 0
            local_ids[11] = 1
            local_ids[12] = 6
            local_ids[13] = 7
            for k1 in range(14,18):
                local_ids[k1] = k1+4
            local_ids[18] = 2
            local_ids[19] = 3
            local_ids[20] = 4
            local_ids[21] = 5
            for k1 in range(22,32):
                local_ids[k1] = k1
            for k1 in range(10,14):
                ue[local_ids[k1]] = ug[dofs[k1]]
                ue[local_ids[k1+8]] = ug[dofs[k1+8]]
            sval = 0.0
            for k1 in range(8):
                ffe[k1] = 0.0    
                fe[k1] = 0.0
                for k2 in range(8):
                    fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
                sval = sval - ue[k1]*fe[k1]
            # cantilever constraints
            if col == 0:
                if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                    fe[0] = 0.0
                    fe[1] = 0.0
                if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                    fe[6] = 0.0
                    fe[7] = 0.0
            for c in range(32):
                Kbb[c][c] = 0.0
                for r in range(c+1,32):
                    Kbb[r][c] = 0.0
                    Kbb[c][r] = 0.0
            for c in range(32):
                if dofs[c] != -1:
                    for r in range(32):
                        for k1 in range(col_ptr[dofs[c]],col_ptr[dofs[c]+1]):    
                            if row_ind[k1] == dofs[r]:
                                Kbb[local_ids[r]][local_ids[c]] = data[k1]
                                Kbb[local_ids[c]][local_ids[r]] = data[k1]
            b0 = 0.0
            b1 = 0.0
            b2 = 0.0
            b3 = 0.0
            if dens[e] == 0:
                for k1 in range(8):
                    Kbb[k1][k1] = Kbb[k1][k1] + dKe[k1][k1]
                    ffe[k1] = ffe[k1] + Kbb[k1][k1]*fe[k1]
                    for k2 in range(k1+1,8):
                        Kbb[k1][k2] = Kbb[k1][k2] + dKe[k1][k2]
                        Kbb[k2][k1] = Kbb[k1][k2]
                        ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
                        ffe[k2] = ffe[k2] + Kbb[k2][k1]*fe[k1]
                    b0 = b0 + fe[k1]*fe[k1]
                    b1 = b1 + fe[k1]*ffe[k1]
                for k1 in range(8,32):
                    ffe[k1] = 0.0
                    for k2 in range(8):
                        ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
                # cantilever constraints
                if col == 0:
                    if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                        ffe[16] = 0.0
                        ffe[17] = 0.0
                    if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                        ffe[0] = 0.0
                        ffe[1] = 0.0
                    if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                        ffe[6] = 0.0
                        ffe[7] = 0.0
                    if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                        ffe[18] = 0.0
                        ffe[19] = 0.0
                elif col == 1:
                    if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                        ffe[8] = 0.0
                        ffe[9] = 0.0
                    if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                        ffe[10] = 0.0
                        ffe[11] = 0.0
                    if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                        ffe[12] = 0.0
                        ffe[13] = 0.0
                    if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                        ffe[14] = 0.0
                        ffe[15] = 0.0
                for k1 in range(32):
                    fffe[k1] = 0.0
                    for k2 in range(32):
                        fffe[k1] = fffe[k1] + Kbb[k1][k2]*ffe[k2]
                    b2 = b2 + ffe[k1]*ffe[k1]
                    b3 = b3 + ffe[k1]*fffe[k1]
                sval = sval + (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
            else:
                for k1 in range(8):
                    Kbb[k1][k1] = Kbb[k1][k1] - dKe[k1][k1]
                    ffe[k1] = ffe[k1] + Kbb[k1][k1]*fe[k1]
                    for k2 in range(k1+1,8):
                        Kbb[k1][k2] = Kbb[k1][k2] - dKe[k1][k2]
                        Kbb[k2][k1] = Kbb[k1][k2]
                        ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
                        ffe[k2] = ffe[k2] + Kbb[k2][k1]*fe[k1]
                    b0 = b0 + fe[k1]*fe[k1]
                    b1 = b1 + fe[k1]*ffe[k1]
                for k1 in range(8,32):
                    ffe[k1] = 0.0
                    for k2 in range(8):
                        ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
                # cantilever constraints
                if col == 0:
                    if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                        ffe[16] = 0.0
                        ffe[17] = 0.0
                    if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                        ffe[0] = 0.0
                        ffe[1] = 0.0
                    if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                        ffe[6] = 0.0
                        ffe[7] = 0.0
                    if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                        ffe[18] = 0.0
                        ffe[19] = 0.0
                elif col == 1:
                    if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                        ffe[8] = 0.0
                        ffe[9] = 0.0
                    if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                        ffe[10] = 0.0
                        ffe[11] = 0.0
                    if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                        ffe[12] = 0.0
                        ffe[13] = 0.0
                    if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                        ffe[14] = 0.0
                        ffe[15] = 0.0
                for k1 in range(32):
                    fffe[k1] = 0.0
                    for k2 in range(32):
                        fffe[k1] = fffe[k1] + Kbb[k1][k2]*ffe[k2]
                    b2 = b2 + ffe[k1]*ffe[k1]
                    b3 = b3 + ffe[k1]*fffe[k1]
                sval = sval - (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
            alpha_r[e] = sval
        free(nodes)
        free(dofs)
        free(local_ids)
        free(ue)
        free(fe)
        free(ffe)
        free(fffe)
        for k0 in range(32):
            free(Kbb[k0])
        free(Kbb)
    return

cdef void cgs_2I_serial(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k1
    cdef long long k2
    cdef long long c
    cdef long long r
    cdef long long row
    cdef long long col
    cdef double b0
    cdef double b1
    cdef double b2
    cdef double b3
    cdef double sval
    cdef long long nodes[16]
    cdef long long dofs[32]
    cdef long long local_ids[32]
    cdef double ue[8]
    cdef double fe[8]
    cdef double ffe[32]
    cdef double fffe[32]
    cdef double Kbb[32][32]
    N = Nx*Ny
    for e in range(N):
        row = e % Ny
        col = e // Ny
        nodes[5]  = e + col
        nodes[0]  = nodes[5] - 2 - Ny
        nodes[1]  = nodes[5] - 1 - Ny
        nodes[2]  = nodes[5] + 0 - Ny
        nodes[3]  = nodes[5] + 1 - Ny
        nodes[4]  = nodes[5] - 1
        nodes[6]  = nodes[5] + 1
        nodes[7]  = nodes[5] + 2
        nodes[8]  = nodes[5] + 0 + Ny
        nodes[9]  = nodes[5] + 1 + Ny
        nodes[10] = nodes[5] + 2 + Ny
        nodes[11] = nodes[5] + 3 + Ny
        nodes[12] = nodes[5] + 1 + Ny*2
        nodes[13] = nodes[5] + 2 + Ny*2
        nodes[14] = nodes[5] + 3 + Ny*2
        nodes[15] = nodes[5] + 4 + Ny*2
        for k1 in range(16):
            dofs[2*k1] = 2*nodes[k1]
            dofs[2*k1+1] = dofs[2*k1] + 1
        if row == 0:
            for k1 in range(4):
                dofs[8*k1]   = -1
                dofs[8*k1+1] = -1
        elif row == Ny-1:
            for k1 in range(4):
                dofs[8*k1+6] = -1
                dofs[8*k1+7] = -1
        if col == 0:
            for k1 in range(4):
                dofs[2*k1]   = -1
                dofs[2*k1+1] = -1
        elif col == Nx-1:
            for k1 in range(4):
                dofs[2*k1+24] = -1
                dofs[2*k1+25] = -1
        for k1 in range(10):
            local_ids[k1] = k1+8
        local_ids[10] = 0
        local_ids[11] = 1
        local_ids[12] = 6
        local_ids[13] = 7
        for k1 in range(14,18):
            local_ids[k1] = k1+4
        local_ids[18] = 2
        local_ids[19] = 3
        local_ids[20] = 4
        local_ids[21] = 5
        for k1 in range(22,32):
            local_ids[k1] = k1
        for k1 in range(10,14):
            ue[local_ids[k1]] = ug[dofs[k1]]
            ue[local_ids[k1+8]] = ug[dofs[k1+8]]
        sval = 0.0
        for k1 in range(8):
            ffe[k1] = 0.0    
            fe[k1] = 0.0
            for k2 in range(8):
                fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
            sval = sval - ue[k1]*fe[k1]
        # cantilever constraints
        if col == 0:
            if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                fe[0] = 0.0
                fe[1] = 0.0
            if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                fe[6] = 0.0
                fe[7] = 0.0
        for c in range(32):
            Kbb[c][c] = 0.0
            for r in range(c+1,32):
                Kbb[r][c] = 0.0
                Kbb[c][r] = 0.0
        for c in range(32):
            if dofs[c] != -1:
                for r in range(32):
                    for k1 in range(col_ptr[dofs[c]],col_ptr[dofs[c]+1]):    
                        if row_ind[k1] == dofs[r]:
                            Kbb[local_ids[r]][local_ids[c]] = data[k1]
                            Kbb[local_ids[c]][local_ids[r]] = data[k1]
        b0 = 0.0
        b1 = 0.0
        b2 = 0.0
        b3 = 0.0
        if dens[e] == 0:
            for k1 in range(8):
                Kbb[k1][k1] = Kbb[k1][k1] + dKe[k1][k1]
                ffe[k1] = ffe[k1] + Kbb[k1][k1]*fe[k1]
                for k2 in range(k1+1,8):
                    Kbb[k1][k2] = Kbb[k1][k2] + dKe[k1][k2]
                    Kbb[k2][k1] = Kbb[k1][k2]
                    ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
                    ffe[k2] = ffe[k2] + Kbb[k2][k1]*fe[k1]
                b0 = b0 + fe[k1]*fe[k1]
                b1 = b1 + fe[k1]*ffe[k1]
            for k1 in range(8,32):
                ffe[k1] = 0.0
                for k2 in range(8):
                    ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
            # cantilever constraints
            if col == 0:
                if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                    ffe[16] = 0.0
                    ffe[17] = 0.0
                if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                    ffe[0] = 0.0
                    ffe[1] = 0.0
                if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                    ffe[6] = 0.0
                    ffe[7] = 0.0
                if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                    ffe[18] = 0.0
                    ffe[19] = 0.0
            elif col == 1:
                if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                    ffe[8] = 0.0
                    ffe[9] = 0.0
                if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                    ffe[10] = 0.0
                    ffe[11] = 0.0
                if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                    ffe[12] = 0.0
                    ffe[13] = 0.0
                if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                    ffe[14] = 0.0
                    ffe[15] = 0.0
            for k1 in range(32):
                fffe[k1] = 0.0
                for k2 in range(32):
                    fffe[k1] = fffe[k1] + Kbb[k1][k2]*ffe[k2]
                b2 = b2 + ffe[k1]*ffe[k1]
                b3 = b3 + ffe[k1]*fffe[k1]
            sval = sval + (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
        else:
            for k1 in range(8):
                Kbb[k1][k1] = Kbb[k1][k1] - dKe[k1][k1]
                ffe[k1] = ffe[k1] + Kbb[k1][k1]*fe[k1]
                for k2 in range(k1+1,8):
                    Kbb[k1][k2] = Kbb[k1][k2] - dKe[k1][k2]
                    Kbb[k2][k1] = Kbb[k1][k2]
                    ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
                    ffe[k2] = ffe[k2] + Kbb[k2][k1]*fe[k1]
                b0 = b0 + fe[k1]*fe[k1]
                b1 = b1 + fe[k1]*ffe[k1]
            for k1 in range(8,32):
                ffe[k1] = 0.0
                for k2 in range(8):
                    ffe[k1] = ffe[k1] + Kbb[k1][k2]*fe[k2]
            # cantilever constraints
            if col == 0:
                if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                    ffe[16] = 0.0
                    ffe[17] = 0.0
                if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                    ffe[0] = 0.0
                    ffe[1] = 0.0
                if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                    ffe[6] = 0.0
                    ffe[7] = 0.0
                if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                    ffe[18] = 0.0
                    ffe[19] = 0.0
            elif col == 1:
                if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                    ffe[8] = 0.0
                    ffe[9] = 0.0
                if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                    ffe[10] = 0.0
                    ffe[11] = 0.0
                if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                    ffe[12] = 0.0
                    ffe[13] = 0.0
                if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                    ffe[14] = 0.0
                    ffe[15] = 0.0
            for k1 in range(32):
                fffe[k1] = 0.0
                for k2 in range(32):
                    fffe[k1] = fffe[k1] + Kbb[k1][k2]*ffe[k2]
                b2 = b2 + ffe[k1]*ffe[k1]
                b3 = b3 + ffe[k1]*fffe[k1]
            sval = sval - (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
        alpha_r[e] = sval
    return

cdef void cgs_2J(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k0
    cdef long long k1
    cdef long long k2
    cdef long long c
    cdef long long r
    cdef long long row
    cdef long long col
    cdef double b0
    cdef double b1
    cdef double b2
    cdef double b3
    cdef double sval
    cdef long long *nodes
    cdef long long *dofs
    cdef long long *local_ids
    cdef double *ue
    cdef double *fe
    cdef double *mfe
    cdef double *ffe
    cdef double *mffe
    cdef double *fffe
    cdef double **Kbb
    N = Nx*Ny
    with nogil, parallel():
        nodes     = <long long*> malloc(16*sizeof(long long))
        dofs      = <long long*> malloc(32*sizeof(long long))
        local_ids = <long long*> malloc(32*sizeof(long long))
        ue        = <double*> malloc(8*sizeof(double))
        fe        = <double*> malloc(8*sizeof(double))
        mfe       = <double*> malloc(8*sizeof(double))
        ffe       = <double*> malloc(32*sizeof(double))
        mffe      = <double*> malloc(32*sizeof(double))
        fffe      = <double*> malloc(32*sizeof(double))
        Kbb       = <double**> malloc(32*sizeof(double *))
        for k0 in range(32):
            Kbb[k0] = <double*> malloc(32*sizeof(double))
        for e in prange(N,schedule='static'):
            row = e % Ny
            col = e // Ny
            nodes[5]  = e + col
            nodes[0]  = nodes[5] - 2 - Ny
            nodes[1]  = nodes[5] - 1 - Ny
            nodes[2]  = nodes[5] + 0 - Ny
            nodes[3]  = nodes[5] + 1 - Ny
            nodes[4]  = nodes[5] - 1
            nodes[6]  = nodes[5] + 1
            nodes[7]  = nodes[5] + 2
            nodes[8]  = nodes[5] + 0 + Ny
            nodes[9]  = nodes[5] + 1 + Ny
            nodes[10] = nodes[5] + 2 + Ny
            nodes[11] = nodes[5] + 3 + Ny
            nodes[12] = nodes[5] + 1 + Ny*2
            nodes[13] = nodes[5] + 2 + Ny*2
            nodes[14] = nodes[5] + 3 + Ny*2
            nodes[15] = nodes[5] + 4 + Ny*2
            for k1 in range(16):
                dofs[2*k1] = 2*nodes[k1]
                dofs[2*k1+1] = dofs[2*k1] + 1
            if row == 0:
                for k1 in range(4):
                    dofs[8*k1]   = -1
                    dofs[8*k1+1] = -1
            elif row == Ny-1:
                for k1 in range(4):
                    dofs[8*k1+6] = -1
                    dofs[8*k1+7] = -1
            if col == 0:
                for k1 in range(4):
                    dofs[2*k1]   = -1
                    dofs[2*k1+1] = -1
            elif col == Nx-1:
                for k1 in range(4):
                    dofs[2*k1+24] = -1
                    dofs[2*k1+25] = -1
            for k1 in range(10):
                local_ids[k1] = k1+8
            local_ids[10] = 0
            local_ids[11] = 1
            local_ids[12] = 6
            local_ids[13] = 7
            for k1 in range(14,18):
                local_ids[k1] = k1+4
            local_ids[18] = 2
            local_ids[19] = 3
            local_ids[20] = 4
            local_ids[21] = 5
            for k1 in range(22,32):
                local_ids[k1] = k1
            for k1 in range(10,14):
                ue[local_ids[k1]] = ug[dofs[k1]]
                ue[local_ids[k1+8]] = ug[dofs[k1+8]]
            sval = 0.0
            for k1 in range(8):
                fe[k1] = 0.0
                for k2 in range(8):
                    fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
                sval = sval - ue[k1]*fe[k1]
            # cantilever constraints
            if col == 0:
                if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                    fe[0] = 0.0
                    fe[1] = 0.0
                if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                    fe[6] = 0.0
                    fe[7] = 0.0
            for c in range(32):
                Kbb[c][c] = 0.0
                for r in range(c+1,32):
                    Kbb[r][c] = 0.0
                    Kbb[c][r] = 0.0
            for c in range(32):
                if dofs[c] != -1:
                    for r in range(32):
                        for k1 in range(col_ptr[dofs[c]],col_ptr[dofs[c]+1]):    
                            if row_ind[k1] == dofs[r]:
                                Kbb[local_ids[r]][local_ids[c]] = data[k1]
                                Kbb[local_ids[c]][local_ids[r]] = data[k1]
            b0 = 0.0
            b1 = 0.0
            b2 = 0.0
            b3 = 0.0
            if dens[e] == 0:
                for k1 in range(8):
                    Kbb[k1][k1] = Kbb[k1][k1] + dKe[k1][k1]
                    mfe[k1] = fe[k1]/Kbb[k1][k1]
                    for k2 in range(k1+1,8):
                        Kbb[k1][k2] = Kbb[k1][k2] + dKe[k1][k2]
                        Kbb[k2][k1] = Kbb[k1][k2]
                    b0 = b0 + fe[k1]*mfe[k1]
                for k1 in range(32):
                    ffe[k1] = 0.0
                    for k2 in range(8):
                        ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
                for k1 in range(8):
                    b1 = b1 + mfe[k1]*ffe[k1]
                # cantilever constraints
                if col == 0:
                    if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                        ffe[16] = 0.0
                        ffe[17] = 0.0
                    if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                        ffe[0] = 0.0
                        ffe[1] = 0.0
                    if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                        ffe[6] = 0.0
                        ffe[7] = 0.0
                    if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                        ffe[18] = 0.0
                        ffe[19] = 0.0
                elif col == 1:
                    if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                        ffe[8] = 0.0
                        ffe[9] = 0.0
                    if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                        ffe[10] = 0.0
                        ffe[11] = 0.0
                    if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                        ffe[12] = 0.0
                        ffe[13] = 0.0
                    if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                        ffe[14] = 0.0
                        ffe[15] = 0.0
                for r in range(32):
                    k1 = local_ids[r]
                    if dofs[r] != -1:
                        mffe[k1] = ffe[k1]/Kbb[k1][k1]
                        b2 = b2 + ffe[k1]*mffe[k1]
                    else:
                        mffe[k1] = 0.0                    
                for k1 in range(32):
                    fffe[k1] = 0.0
                    for k2 in range(32):
                        fffe[k1] = fffe[k1] + Kbb[k1][k2]*mffe[k2]
                    b3 = b3 + mffe[k1]*fffe[k1]
                sval = sval + (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
            else:
                for k1 in range(8):
                    Kbb[k1][k1] = Kbb[k1][k1] - dKe[k1][k1]
                    mfe[k1] = fe[k1]/Kbb[k1][k1]
                    for k2 in range(k1+1,8):
                        Kbb[k1][k2] = Kbb[k1][k2] - dKe[k1][k2]
                        Kbb[k2][k1] = Kbb[k1][k2]
                    b0 = b0 + fe[k1]*mfe[k1]
                for k1 in range(32):
                    ffe[k1] = 0.0
                    for k2 in range(8):
                        ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
                for k1 in range(8):
                    b1 = b1 + mfe[k1]*ffe[k1]
                # cantilever constraints
                if col == 0:
                    if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                        ffe[16] = 0.0
                        ffe[17] = 0.0
                    if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                        ffe[0] = 0.0
                        ffe[1] = 0.0
                    if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                        ffe[6] = 0.0
                        ffe[7] = 0.0
                    if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                        ffe[18] = 0.0
                        ffe[19] = 0.0
                elif col == 1:
                    if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                        ffe[8] = 0.0
                        ffe[9] = 0.0
                    if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                        ffe[10] = 0.0
                        ffe[11] = 0.0
                    if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                        ffe[12] = 0.0
                        ffe[13] = 0.0
                    if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                        ffe[14] = 0.0
                        ffe[15] = 0.0
                for r in range(32):
                    k1 = local_ids[r]
                    if dofs[r] != -1:
                        mffe[k1] = ffe[k1]/Kbb[k1][k1]
                        b2 = b2 + ffe[k1]*mffe[k1]
                    else:
                        mffe[k1] = 0.0
                for k1 in range(32):
                    fffe[k1] = 0.0
                    for k2 in range(32):
                        fffe[k1] = fffe[k1] + Kbb[k1][k2]*mffe[k2]
                    b3 = b3 + mffe[k1]*fffe[k1]
                sval = sval - (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
            alpha_r[e] = sval
        free(nodes)
        free(dofs)
        free(local_ids)
        free(ue)
        free(fe)
        free(mfe)
        free(ffe)
        free(mffe)
        free(fffe)
        for k0 in range(32):
            free(Kbb[k0])
        free(Kbb)
    return

cdef void cgs_2J_serial(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    cdef long long k1
    cdef long long k2
    cdef long long c
    cdef long long r
    cdef long long row
    cdef long long col
    cdef double b0
    cdef double b1
    cdef double b2
    cdef double b3
    cdef double sval
    cdef long long nodes[16]
    cdef long long dofs[32]
    cdef long long local_ids[32]
    cdef double ue[8]
    cdef double fe[8]
    cdef double mfe[8]
    cdef double ffe[32]
    cdef double mffe[32]
    cdef double fffe[32]
    cdef double Kbb[32][32]
    N = Nx*Ny
    for e in range(N):
        row = e % Ny
        col = e // Ny
        nodes[5]  = e + col
        nodes[0]  = nodes[5] - 2 - Ny
        nodes[1]  = nodes[5] - 1 - Ny
        nodes[2]  = nodes[5] + 0 - Ny
        nodes[3]  = nodes[5] + 1 - Ny
        nodes[4]  = nodes[5] - 1
        nodes[6]  = nodes[5] + 1
        nodes[7]  = nodes[5] + 2
        nodes[8]  = nodes[5] + 0 + Ny
        nodes[9]  = nodes[5] + 1 + Ny
        nodes[10] = nodes[5] + 2 + Ny
        nodes[11] = nodes[5] + 3 + Ny
        nodes[12] = nodes[5] + 1 + Ny*2
        nodes[13] = nodes[5] + 2 + Ny*2
        nodes[14] = nodes[5] + 3 + Ny*2
        nodes[15] = nodes[5] + 4 + Ny*2
        for k1 in range(16):
            dofs[2*k1] = 2*nodes[k1]
            dofs[2*k1+1] = dofs[2*k1] + 1
        if row == 0:
            for k1 in range(4):
                dofs[8*k1]   = -1
                dofs[8*k1+1] = -1
        elif row == Ny-1:
            for k1 in range(4):
                dofs[8*k1+6] = -1
                dofs[8*k1+7] = -1
        if col == 0:
            for k1 in range(4):
                dofs[2*k1]   = -1
                dofs[2*k1+1] = -1
        elif col == Nx-1:
            for k1 in range(4):
                dofs[2*k1+24] = -1
                dofs[2*k1+25] = -1
        for k1 in range(10):
            local_ids[k1] = k1+8
        local_ids[10] = 0
        local_ids[11] = 1
        local_ids[12] = 6
        local_ids[13] = 7
        for k1 in range(14,18):
            local_ids[k1] = k1+4
        local_ids[18] = 2
        local_ids[19] = 3
        local_ids[20] = 4
        local_ids[21] = 5
        for k1 in range(22,32):
            local_ids[k1] = k1
        for k1 in range(10,14):
            ue[local_ids[k1]] = ug[dofs[k1]]
            ue[local_ids[k1+8]] = ug[dofs[k1+8]]
        sval = 0.0
        for k1 in range(8):
            fe[k1] = 0.0
            for k2 in range(8):
                fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
            sval = sval - ue[k1]*fe[k1]
        # cantilever constraints
        if col == 0:
            if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                fe[0] = 0.0
                fe[1] = 0.0
            if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                fe[6] = 0.0
                fe[7] = 0.0
        for c in range(32):
            Kbb[c][c] = 0.0
            for r in range(c+1,32):
                Kbb[r][c] = 0.0
                Kbb[c][r] = 0.0
        for c in range(32):
            if dofs[c] != -1:
                for r in range(32):
                    for k1 in range(col_ptr[dofs[c]],col_ptr[dofs[c]+1]):    
                        if row_ind[k1] == dofs[r]:
                            Kbb[local_ids[r]][local_ids[c]] = data[k1]
                            Kbb[local_ids[c]][local_ids[r]] = data[k1]
        b0 = 0.0
        b1 = 0.0
        b2 = 0.0
        b3 = 0.0
        if dens[e] == 0:
            for k1 in range(8):
                Kbb[k1][k1] = Kbb[k1][k1] + dKe[k1][k1]
                mfe[k1] = fe[k1]/Kbb[k1][k1]
                for k2 in range(k1+1,8):
                    Kbb[k1][k2] = Kbb[k1][k2] + dKe[k1][k2]
                    Kbb[k2][k1] = Kbb[k1][k2]
                b0 = b0 + fe[k1]*mfe[k1]
            for k1 in range(32):
                ffe[k1] = 0.0
                for k2 in range(8):
                    ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
            for k1 in range(8):
                b1 = b1 + mfe[k1]*ffe[k1]
            # cantilever constraints
            if col == 0:
                if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                    ffe[16] = 0.0
                    ffe[17] = 0.0
                if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                    ffe[0] = 0.0
                    ffe[1] = 0.0
                if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                    ffe[6] = 0.0
                    ffe[7] = 0.0
                if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                    ffe[18] = 0.0
                    ffe[19] = 0.0
            elif col == 1:
                if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                    ffe[8] = 0.0
                    ffe[9] = 0.0
                if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                    ffe[10] = 0.0
                    ffe[11] = 0.0
                if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                    ffe[12] = 0.0
                    ffe[13] = 0.0
                if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                    ffe[14] = 0.0
                    ffe[15] = 0.0
            for r in range(32):
                k1 = local_ids[r]
                if dofs[r] != -1:
                    mffe[k1] = ffe[k1]/Kbb[k1][k1]
                    b2 = b2 + ffe[k1]*mffe[k1]
                else:
                    mffe[k1] = 0.0                    
            for k1 in range(32):
                fffe[k1] = 0.0
                for k2 in range(32):
                    fffe[k1] = fffe[k1] + Kbb[k1][k2]*mffe[k2]
                b3 = b3 + mffe[k1]*fffe[k1]
            sval = sval + (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
        else:
            for k1 in range(8):
                Kbb[k1][k1] = Kbb[k1][k1] - dKe[k1][k1]
                mfe[k1] = fe[k1]/Kbb[k1][k1]
                for k2 in range(k1+1,8):
                    Kbb[k1][k2] = Kbb[k1][k2] - dKe[k1][k2]
                    Kbb[k2][k1] = Kbb[k1][k2]
                b0 = b0 + fe[k1]*mfe[k1]
            for k1 in range(32):
                ffe[k1] = 0.0
                for k2 in range(8):
                    ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
            for k1 in range(8):
                b1 = b1 + mfe[k1]*ffe[k1]
            # cantilever constraints
            if col == 0:
                if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                    ffe[16] = 0.0
                    ffe[17] = 0.0
                if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                    ffe[0] = 0.0
                    ffe[1] = 0.0
                if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                    ffe[6] = 0.0
                    ffe[7] = 0.0
                if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                    ffe[18] = 0.0
                    ffe[19] = 0.0
            elif col == 1:
                if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                    ffe[8] = 0.0
                    ffe[9] = 0.0
                if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                    ffe[10] = 0.0
                    ffe[11] = 0.0
                if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                    ffe[12] = 0.0
                    ffe[13] = 0.0
                if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                    ffe[14] = 0.0
                    ffe[15] = 0.0
            for r in range(32):
                k1 = local_ids[r]
                if dofs[r] != -1:
                    mffe[k1] = ffe[k1]/Kbb[k1][k1]
                    b2 = b2 + ffe[k1]*mffe[k1]
                else:
                    mffe[k1] = 0.0
            for k1 in range(32):
                fffe[k1] = 0.0
                for k2 in range(32):
                    fffe[k1] = fffe[k1] + Kbb[k1][k2]*mffe[k2]
                b3 = b3 + mffe[k1]*fffe[k1]
            sval = sval - (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
        alpha_r[e] = sval
    return

cdef void sens(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny, long long void_sens):
    cdef long long connected
    cdef long long N
    cdef long long e
    cdef long long k0
    cdef long long k1
    cdef long long k2
    cdef long long c
    cdef long long r
    cdef long long row
    cdef long long col
    cdef double b0
    cdef double b1
    cdef double b2
    cdef double b3
    cdef double sval
    cdef long long *nodes
    cdef long long *dofs
    cdef long long *local_ids
    cdef double *ue
    cdef double *fe
    cdef double *mfe
    cdef double *ffe
    cdef double *mffe
    cdef double *fffe
    cdef double **Kbb
    N = Nx*Ny
    with nogil, parallel():
        nodes     = <long long*> malloc(16*sizeof(long long))
        dofs      = <long long*> malloc(32*sizeof(long long))
        local_ids = <long long*> malloc(32*sizeof(long long))
        ue        = <double*> malloc(8*sizeof(double))
        fe        = <double*> malloc(8*sizeof(double))
        mfe       = <double*> malloc(8*sizeof(double))
        ffe       = <double*> malloc(32*sizeof(double))
        mffe      = <double*> malloc(32*sizeof(double))
        fffe      = <double*> malloc(32*sizeof(double))
        Kbb       = <double**> malloc(32*sizeof(double *))
        for k0 in range(32):
            Kbb[k0] = <double*> malloc(32*sizeof(double))
        for e in prange(N,schedule='static'):
            row = e % Ny
            col = e // Ny
            if dens[e] == 0:
                if void_sens == 0:
                    sval = 0.0
                else:
                    if row == 0:
                        if col == 0:
                            connected = dens[e+1] + dens[e+Ny]
                        elif col == Nx-1:
                            connected = dens[e+1] + dens[e-Ny]
                        else:
                            connected = dens[e+1] + dens[e+Ny] + dens[e-Ny]
                    elif row == Ny-1:
                        if col == 0:
                            connected = dens[e-1] + dens[e+Ny]
                        elif col == Nx-1:
                            connected = dens[e-1] + dens[e-Ny]
                        else:
                            connected = dens[e-1] + dens[e+Ny] + dens[e-Ny]
                    else:
                        if col == 0:
                            connected = dens[e-1] + dens[e+1] + dens[e+Ny]
                        elif col == Nx-1:
                            connected = dens[e-1] + dens[e+1] + dens[e-Ny]
                        else:
                            connected = dens[e-1] + dens[e+1] + dens[e+Ny] + dens[e-Ny]
                    if connected == 0:
                        sval = 0.0
                    else:
                        nodes[5]  = e + col
                        nodes[0]  = nodes[5] - 2 - Ny
                        nodes[1]  = nodes[5] - 1 - Ny
                        nodes[2]  = nodes[5] + 0 - Ny
                        nodes[3]  = nodes[5] + 1 - Ny
                        nodes[4]  = nodes[5] - 1
                        nodes[6]  = nodes[5] + 1
                        nodes[7]  = nodes[5] + 2
                        nodes[8]  = nodes[5] + 0 + Ny
                        nodes[9]  = nodes[5] + 1 + Ny
                        nodes[10] = nodes[5] + 2 + Ny
                        nodes[11] = nodes[5] + 3 + Ny
                        nodes[12] = nodes[5] + 1 + Ny*2
                        nodes[13] = nodes[5] + 2 + Ny*2
                        nodes[14] = nodes[5] + 3 + Ny*2
                        nodes[15] = nodes[5] + 4 + Ny*2
                        for k1 in range(16):
                            dofs[2*k1] = 2*nodes[k1]
                            dofs[2*k1+1] = dofs[2*k1] + 1
                        if row == 0:
                            for k1 in range(4):
                                dofs[8*k1]   = -1
                                dofs[8*k1+1] = -1
                        elif row == Ny-1:
                            for k1 in range(4):
                                dofs[8*k1+6] = -1
                                dofs[8*k1+7] = -1
                        if col == 0:
                            for k1 in range(4):
                                dofs[2*k1]   = -1
                                dofs[2*k1+1] = -1
                        elif col == Nx-1:
                            for k1 in range(4):
                                dofs[2*k1+24] = -1
                                dofs[2*k1+25] = -1
                        for k1 in range(10):
                            local_ids[k1] = k1+8
                        local_ids[10] = 0
                        local_ids[11] = 1
                        local_ids[12] = 6
                        local_ids[13] = 7
                        for k1 in range(14,18):
                            local_ids[k1] = k1+4
                        local_ids[18] = 2
                        local_ids[19] = 3
                        local_ids[20] = 4
                        local_ids[21] = 5
                        for k1 in range(22,32):
                            local_ids[k1] = k1
                        for k1 in range(10,14):
                            ue[local_ids[k1]] = ug[dofs[k1]]
                            ue[local_ids[k1+8]] = ug[dofs[k1+8]]
                        sval = 0.0
                        for k1 in range(8):
                            fe[k1] = 0.0
                            for k2 in range(8):
                                fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
                            sval = sval - ue[k1]*fe[k1]
                        # cantilever constraints
                        if col == 0:
                            if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                                fe[0] = 0.0
                                fe[1] = 0.0
                            if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                                fe[6] = 0.0
                                fe[7] = 0.0
                        for c in range(32):
                            Kbb[c][c] = 0.0
                            for r in range(c+1,32):
                                Kbb[r][c] = 0.0
                                Kbb[c][r] = 0.0
                        for c in range(32):
                            if dofs[c] != -1:
                                for r in range(32):
                                    for k1 in range(col_ptr[dofs[c]],col_ptr[dofs[c]+1]):    
                                        if row_ind[k1] == dofs[r]:
                                            Kbb[local_ids[r]][local_ids[c]] = data[k1]
                                            Kbb[local_ids[c]][local_ids[r]] = data[k1]
                        b0 = 0.0
                        b1 = 0.0
                        b2 = 0.0
                        b3 = 0.0
                        for k1 in range(8):
                            Kbb[k1][k1] = Kbb[k1][k1] + dKe[k1][k1]
                            mfe[k1] = fe[k1]/Kbb[k1][k1]
                            for k2 in range(k1+1,8):
                                Kbb[k1][k2] = Kbb[k1][k2] + dKe[k1][k2]
                                Kbb[k2][k1] = Kbb[k1][k2]
                            b0 = b0 + fe[k1]*mfe[k1]
                        for k1 in range(32):
                            ffe[k1] = 0.0
                            for k2 in range(8):
                                ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
                        for k1 in range(8):
                            b1 = b1 + mfe[k1]*ffe[k1]
                        # cantilever constraints
                        if col == 0:
                            if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                                ffe[16] = 0.0
                                ffe[17] = 0.0
                            if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                                ffe[0] = 0.0
                                ffe[1] = 0.0
                            if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                                ffe[6] = 0.0
                                ffe[7] = 0.0
                            if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                                ffe[18] = 0.0
                                ffe[19] = 0.0
                        elif col == 1:
                            if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                                ffe[8] = 0.0
                                ffe[9] = 0.0
                            if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                                ffe[10] = 0.0
                                ffe[11] = 0.0
                            if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                                ffe[12] = 0.0
                                ffe[13] = 0.0
                            if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                                ffe[14] = 0.0
                                ffe[15] = 0.0
                        for r in range(32):
                            k1 = local_ids[r]
                            if dofs[r] != -1:
                                mffe[k1] = ffe[k1]/Kbb[k1][k1]
                                b2 = b2 + ffe[k1]*mffe[k1]
                            else:
                                mffe[k1] = 0.0
                        for k1 in range(32):
                            fffe[k1] = 0.0
                            for k2 in range(32):
                                fffe[k1] = fffe[k1] + Kbb[k1][k2]*mffe[k2]
                            b3 = b3 + mffe[k1]*fffe[k1]
                        sval = sval + (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
            else:
                nodes[5]  = e + col
                nodes[0]  = nodes[5] - 2 - Ny
                nodes[1]  = nodes[5] - 1 - Ny
                nodes[2]  = nodes[5] + 0 - Ny
                nodes[3]  = nodes[5] + 1 - Ny
                nodes[4]  = nodes[5] - 1
                nodes[6]  = nodes[5] + 1
                nodes[7]  = nodes[5] + 2
                nodes[8]  = nodes[5] + 0 + Ny
                nodes[9]  = nodes[5] + 1 + Ny
                nodes[10] = nodes[5] + 2 + Ny
                nodes[11] = nodes[5] + 3 + Ny
                nodes[12] = nodes[5] + 1 + Ny*2
                nodes[13] = nodes[5] + 2 + Ny*2
                nodes[14] = nodes[5] + 3 + Ny*2
                nodes[15] = nodes[5] + 4 + Ny*2
                for k1 in range(16):
                    dofs[2*k1] = 2*nodes[k1]
                    dofs[2*k1+1] = dofs[2*k1] + 1
                if row == 0:
                    for k1 in range(4):
                        dofs[8*k1]   = -1
                        dofs[8*k1+1] = -1
                elif row == Ny-1:
                    for k1 in range(4):
                        dofs[8*k1+6] = -1
                        dofs[8*k1+7] = -1
                if col == 0:
                    for k1 in range(4):
                        dofs[2*k1]   = -1
                        dofs[2*k1+1] = -1
                elif col == Nx-1:
                    for k1 in range(4):
                        dofs[2*k1+24] = -1
                        dofs[2*k1+25] = -1
                for k1 in range(10):
                    local_ids[k1] = k1+8
                local_ids[10] = 0
                local_ids[11] = 1
                local_ids[12] = 6
                local_ids[13] = 7
                for k1 in range(14,18):
                    local_ids[k1] = k1+4
                local_ids[18] = 2
                local_ids[19] = 3
                local_ids[20] = 4
                local_ids[21] = 5
                for k1 in range(22,32):
                    local_ids[k1] = k1
                for k1 in range(10,14):
                    ue[local_ids[k1]] = ug[dofs[k1]]
                    ue[local_ids[k1+8]] = ug[dofs[k1+8]]
                sval = 0.0
                for k1 in range(8):
                    fe[k1] = 0.0
                    for k2 in range(8):
                        fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
                    sval = sval - ue[k1]*fe[k1]
                # cantilever constraints
                if col == 0:
                    if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                        fe[0] = 0.0
                        fe[1] = 0.0
                    if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                        fe[6] = 0.0
                        fe[7] = 0.0
                for c in range(32):
                    Kbb[c][c] = 0.0
                    for r in range(c+1,32):
                        Kbb[r][c] = 0.0
                        Kbb[c][r] = 0.0
                for c in range(32):
                    if dofs[c] != -1:
                        for r in range(32):
                            for k1 in range(col_ptr[dofs[c]],col_ptr[dofs[c]+1]):    
                                if row_ind[k1] == dofs[r]:
                                    Kbb[local_ids[r]][local_ids[c]] = data[k1]
                                    Kbb[local_ids[c]][local_ids[r]] = data[k1]
                b0 = 0.0
                b1 = 0.0
                b2 = 0.0
                b3 = 0.0
                for k1 in range(8):
                    Kbb[k1][k1] = Kbb[k1][k1] - dKe[k1][k1]
                    mfe[k1] = fe[k1]/Kbb[k1][k1]
                    for k2 in range(k1+1,8):
                        Kbb[k1][k2] = Kbb[k1][k2] - dKe[k1][k2]
                        Kbb[k2][k1] = Kbb[k1][k2]
                    b0 = b0 + fe[k1]*mfe[k1]
                for k1 in range(32):
                    ffe[k1] = 0.0
                    for k2 in range(8):
                        ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
                for k1 in range(8):
                    b1 = b1 + mfe[k1]*ffe[k1]
                # cantilever constraints
                if col == 0:
                    if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                        ffe[16] = 0.0
                        ffe[17] = 0.0
                    if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                        ffe[0] = 0.0
                        ffe[1] = 0.0
                    if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                        ffe[6] = 0.0
                        ffe[7] = 0.0
                    if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                        ffe[18] = 0.0
                        ffe[19] = 0.0
                elif col == 1:
                    if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                        ffe[8] = 0.0
                        ffe[9] = 0.0
                    if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                        ffe[10] = 0.0
                        ffe[11] = 0.0
                    if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                        ffe[12] = 0.0
                        ffe[13] = 0.0
                    if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                        ffe[14] = 0.0
                        ffe[15] = 0.0
                for r in range(32):
                    k1 = local_ids[r]
                    if dofs[r] != -1:
                        mffe[k1] = ffe[k1]/Kbb[k1][k1]
                        b2 = b2 + ffe[k1]*mffe[k1]
                    else:
                        mffe[k1] = 0.0
                for k1 in range(32):
                    fffe[k1] = 0.0
                    for k2 in range(32):
                        fffe[k1] = fffe[k1] + Kbb[k1][k2]*mffe[k2]
                    b3 = b3 + mffe[k1]*fffe[k1]
                sval = sval - (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
            alpha_r[e] = sval
        free(nodes)
        free(dofs)
        free(local_ids)
        free(ue)
        free(fe)
        free(mfe)
        free(ffe)
        free(mffe)
        free(fffe)
        for k0 in range(32):
            free(Kbb[k0])
        free(Kbb)
    return

cdef void sens_serial(double [:] alpha_r, long long [:] dens, double [:] data, long long [:] row_ind, long long [:] col_ptr, long long [:] bc_lim, double [:,::1] dKe, double [:] ug, long long Nx, long long Ny, long long void_sens):
    cdef long long connected
    cdef long long N
    cdef long long e
    cdef long long k0
    cdef long long k1
    cdef long long k2
    cdef long long c
    cdef long long r
    cdef long long row
    cdef long long col
    cdef double b0
    cdef double b1
    cdef double b2
    cdef double b3
    cdef double sval
    cdef long long nodes[16]
    cdef long long dofs[32]
    cdef long long local_ids[32]
    cdef double ue[8]
    cdef double fe[8]
    cdef double mfe[8]
    cdef double ffe[32]
    cdef double mffe[32]
    cdef double fffe[32]
    cdef double Kbb[32][32]
    N = Nx*Ny
    for e in range(N):
        row = e % Ny
        col = e // Ny
        if dens[e] == 0:
            if void_sens == 0:
                sval = 0.0
            else:
                if row == 0:
                    if col == 0:
                        connected = dens[e+1] + dens[e+Ny]
                    elif col == Nx-1:
                        connected = dens[e+1] + dens[e-Ny]
                    else:
                        connected = dens[e+1] + dens[e+Ny] + dens[e-Ny]
                elif row == Ny-1:
                    if col == 0:
                        connected = dens[e-1] + dens[e+Ny]
                    elif col == Nx-1:
                        connected = dens[e-1] + dens[e-Ny]
                    else:
                        connected = dens[e-1] + dens[e+Ny] + dens[e-Ny]
                else:
                    if col == 0:
                        connected = dens[e-1] + dens[e+1] + dens[e+Ny]
                    elif col == Nx-1:
                        connected = dens[e-1] + dens[e+1] + dens[e-Ny]
                    else:
                        connected = dens[e-1] + dens[e+1] + dens[e+Ny] + dens[e-Ny]
                if connected == 0:
                    sval = 0.0
                else:
                    nodes[5]  = e + col
                    nodes[0]  = nodes[5] - 2 - Ny
                    nodes[1]  = nodes[5] - 1 - Ny
                    nodes[2]  = nodes[5] + 0 - Ny
                    nodes[3]  = nodes[5] + 1 - Ny
                    nodes[4]  = nodes[5] - 1
                    nodes[6]  = nodes[5] + 1
                    nodes[7]  = nodes[5] + 2
                    nodes[8]  = nodes[5] + 0 + Ny
                    nodes[9]  = nodes[5] + 1 + Ny
                    nodes[10] = nodes[5] + 2 + Ny
                    nodes[11] = nodes[5] + 3 + Ny
                    nodes[12] = nodes[5] + 1 + Ny*2
                    nodes[13] = nodes[5] + 2 + Ny*2
                    nodes[14] = nodes[5] + 3 + Ny*2
                    nodes[15] = nodes[5] + 4 + Ny*2
                    for k1 in range(16):
                        dofs[2*k1] = 2*nodes[k1]
                        dofs[2*k1+1] = dofs[2*k1] + 1
                    if row == 0:
                        for k1 in range(4):
                            dofs[8*k1]   = -1
                            dofs[8*k1+1] = -1
                    elif row == Ny-1:
                        for k1 in range(4):
                            dofs[8*k1+6] = -1
                            dofs[8*k1+7] = -1
                    if col == 0:
                        for k1 in range(4):
                            dofs[2*k1]   = -1
                            dofs[2*k1+1] = -1
                    elif col == Nx-1:
                        for k1 in range(4):
                            dofs[2*k1+24] = -1
                            dofs[2*k1+25] = -1
                    for k1 in range(10):
                        local_ids[k1] = k1+8
                    local_ids[10] = 0
                    local_ids[11] = 1
                    local_ids[12] = 6
                    local_ids[13] = 7
                    for k1 in range(14,18):
                        local_ids[k1] = k1+4
                    local_ids[18] = 2
                    local_ids[19] = 3
                    local_ids[20] = 4
                    local_ids[21] = 5
                    for k1 in range(22,32):
                        local_ids[k1] = k1
                    for k1 in range(10,14):
                        ue[local_ids[k1]] = ug[dofs[k1]]
                        ue[local_ids[k1+8]] = ug[dofs[k1+8]]
                    sval = 0.0
                    for k1 in range(8):
                        fe[k1] = 0.0
                        for k2 in range(8):
                            fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
                        sval = sval - ue[k1]*fe[k1]
                    # cantilever constraints
                    if col == 0:
                        if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                            fe[0] = 0.0
                            fe[1] = 0.0
                        if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                            fe[6] = 0.0
                            fe[7] = 0.0
                    for c in range(32):
                        Kbb[c][c] = 0.0
                        for r in range(c+1,32):
                            Kbb[r][c] = 0.0
                            Kbb[c][r] = 0.0
                    for c in range(32):
                        if dofs[c] != -1:
                            for r in range(32):
                                for k1 in range(col_ptr[dofs[c]],col_ptr[dofs[c]+1]):    
                                    if row_ind[k1] == dofs[r]:
                                        Kbb[local_ids[r]][local_ids[c]] = data[k1]
                                        Kbb[local_ids[c]][local_ids[r]] = data[k1]
                    b0 = 0.0
                    b1 = 0.0
                    b2 = 0.0
                    b3 = 0.0
                    for k1 in range(8):
                        Kbb[k1][k1] = Kbb[k1][k1] + dKe[k1][k1]
                        mfe[k1] = fe[k1]/Kbb[k1][k1]
                        for k2 in range(k1+1,8):
                            Kbb[k1][k2] = Kbb[k1][k2] + dKe[k1][k2]
                            Kbb[k2][k1] = Kbb[k1][k2]
                        b0 = b0 + fe[k1]*mfe[k1]
                    for k1 in range(32):
                        ffe[k1] = 0.0
                        for k2 in range(8):
                            ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
                    for k1 in range(8):
                        b1 = b1 + mfe[k1]*ffe[k1]
                    # cantilever constraints
                    if col == 0:
                        if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                            ffe[16] = 0.0
                            ffe[17] = 0.0
                        if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                            ffe[0] = 0.0
                            ffe[1] = 0.0
                        if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                            ffe[6] = 0.0
                            ffe[7] = 0.0
                        if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                            ffe[18] = 0.0
                            ffe[19] = 0.0
                    elif col == 1:
                        if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                            ffe[8] = 0.0
                            ffe[9] = 0.0
                        if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                            ffe[10] = 0.0
                            ffe[11] = 0.0
                        if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                            ffe[12] = 0.0
                            ffe[13] = 0.0
                        if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                            ffe[14] = 0.0
                            ffe[15] = 0.0
                    for r in range(32):
                        k1 = local_ids[r]
                        if dofs[r] != -1:
                            mffe[k1] = ffe[k1]/Kbb[k1][k1]
                            b2 = b2 + ffe[k1]*mffe[k1]
                        else:
                            mffe[k1] = 0.0
                    for k1 in range(32):
                        fffe[k1] = 0.0
                        for k2 in range(32):
                            fffe[k1] = fffe[k1] + Kbb[k1][k2]*mffe[k2]
                        b3 = b3 + mffe[k1]*fffe[k1]
                    sval = sval + (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
        else:
            nodes[5]  = e + col
            nodes[0]  = nodes[5] - 2 - Ny
            nodes[1]  = nodes[5] - 1 - Ny
            nodes[2]  = nodes[5] + 0 - Ny
            nodes[3]  = nodes[5] + 1 - Ny
            nodes[4]  = nodes[5] - 1
            nodes[6]  = nodes[5] + 1
            nodes[7]  = nodes[5] + 2
            nodes[8]  = nodes[5] + 0 + Ny
            nodes[9]  = nodes[5] + 1 + Ny
            nodes[10] = nodes[5] + 2 + Ny
            nodes[11] = nodes[5] + 3 + Ny
            nodes[12] = nodes[5] + 1 + Ny*2
            nodes[13] = nodes[5] + 2 + Ny*2
            nodes[14] = nodes[5] + 3 + Ny*2
            nodes[15] = nodes[5] + 4 + Ny*2
            for k1 in range(16):
                dofs[2*k1] = 2*nodes[k1]
                dofs[2*k1+1] = dofs[2*k1] + 1
            if row == 0:
                for k1 in range(4):
                    dofs[8*k1]   = -1
                    dofs[8*k1+1] = -1
            elif row == Ny-1:
                for k1 in range(4):
                    dofs[8*k1+6] = -1
                    dofs[8*k1+7] = -1
            if col == 0:
                for k1 in range(4):
                    dofs[2*k1]   = -1
                    dofs[2*k1+1] = -1
            elif col == Nx-1:
                for k1 in range(4):
                    dofs[2*k1+24] = -1
                    dofs[2*k1+25] = -1
            for k1 in range(10):
                local_ids[k1] = k1+8
            local_ids[10] = 0
            local_ids[11] = 1
            local_ids[12] = 6
            local_ids[13] = 7
            for k1 in range(14,18):
                local_ids[k1] = k1+4
            local_ids[18] = 2
            local_ids[19] = 3
            local_ids[20] = 4
            local_ids[21] = 5
            for k1 in range(22,32):
                local_ids[k1] = k1
            for k1 in range(10,14):
                ue[local_ids[k1]] = ug[dofs[k1]]
                ue[local_ids[k1+8]] = ug[dofs[k1+8]]
            sval = 0.0
            for k1 in range(8):
                fe[k1] = 0.0
                for k2 in range(8):
                    fe[k1] = fe[k1] + dKe[k1][k2]*ue[k2]
                sval = sval - ue[k1]*fe[k1]
            # cantilever constraints
            if col == 0:
                if (e >= bc_lim[0]) and (e <= bc_lim[1]):
                    fe[0] = 0.0
                    fe[1] = 0.0
                if (e+1 >= bc_lim[0]) and (e+1 <= bc_lim[1]):
                    fe[6] = 0.0
                    fe[7] = 0.0
            for c in range(32):
                Kbb[c][c] = 0.0
                for r in range(c+1,32):
                    Kbb[r][c] = 0.0
                    Kbb[c][r] = 0.0
            for c in range(32):
                if dofs[c] != -1:
                    for r in range(32):
                        for k1 in range(col_ptr[dofs[c]],col_ptr[dofs[c]+1]):    
                            if row_ind[k1] == dofs[r]:
                                Kbb[local_ids[r]][local_ids[c]] = data[k1]
                                Kbb[local_ids[c]][local_ids[r]] = data[k1]
            b0 = 0.0
            b1 = 0.0
            b2 = 0.0
            b3 = 0.0
            for k1 in range(8):
                Kbb[k1][k1] = Kbb[k1][k1] - dKe[k1][k1]
                mfe[k1] = fe[k1]/Kbb[k1][k1]
                for k2 in range(k1+1,8):
                    Kbb[k1][k2] = Kbb[k1][k2] - dKe[k1][k2]
                    Kbb[k2][k1] = Kbb[k1][k2]
                b0 = b0 + fe[k1]*mfe[k1]
            for k1 in range(32):
                ffe[k1] = 0.0
                for k2 in range(8):
                    ffe[k1] = ffe[k1] + Kbb[k1][k2]*mfe[k2]
            for k1 in range(8):
                b1 = b1 + mfe[k1]*ffe[k1]
            # cantilever constraints
            if col == 0:
                if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                    ffe[16] = 0.0
                    ffe[17] = 0.0
                if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                    ffe[0] = 0.0
                    ffe[1] = 0.0
                if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                    ffe[6] = 0.0
                    ffe[7] = 0.0
                if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                    ffe[18] = 0.0
                    ffe[19] = 0.0
            elif col == 1:
                if (row-1 >= bc_lim[0]) and (row-1 <= bc_lim[1]):
                    ffe[8] = 0.0
                    ffe[9] = 0.0
                if (row >= bc_lim[0]) and (row <= bc_lim[1]):
                    ffe[10] = 0.0
                    ffe[11] = 0.0
                if (row+1 >= bc_lim[0]) and (row+1 <= bc_lim[1]):
                    ffe[12] = 0.0
                    ffe[13] = 0.0
                if (row+2 >= bc_lim[0]) and (row+2 <= bc_lim[1]):
                    ffe[14] = 0.0
                    ffe[15] = 0.0
            for r in range(32):
                k1 = local_ids[r]
                if dofs[r] != -1:
                    mffe[k1] = ffe[k1]/Kbb[k1][k1]
                    b2 = b2 + ffe[k1]*mffe[k1]
                else:
                    mffe[k1] = 0.0
            for k1 in range(32):
                fffe[k1] = 0.0
                for k2 in range(32):
                    fffe[k1] = fffe[k1] + Kbb[k1][k2]*mffe[k2]
                b3 = b3 + mffe[k1]*fffe[k1]
            sval = sval - (b0*b0*b3 - 2*b0*b1*b2 + b1*b1*b1)/(b1*b3-b2*b2)
        alpha_r[e] = sval
    return

def str_update_sinv(Kinv_csc, Q, T, serial=False):
    data = Kinv_csc.data
    row_ind = Kinv_csc.indices.astype("int64")
    col_ptr = Kinv_csc.indptr.astype("int64")
    if serial:
        update_sinv_serial(data, row_ind, col_ptr, Q, T, len(col_ptr)-1, len(Q))
    else:
        update_sinv(data, row_ind, col_ptr, Q, T, len(T), len(Q))
    return

def str_ws(alpha_r, x, Kinv_csc, bc_lim, H, H_01, H_67, H_0167, ur, Nx, Ny, serial=False):
    dens = x.astype("int64")
    data = Kinv_csc.data
    row_ind = Kinv_csc.indices.astype("int64")
    col_ptr = Kinv_csc.indptr.astype("int64")
    if serial:
        ws_serial(alpha_r, dens, data, row_ind, col_ptr, bc_lim, H, H_01, H_67, H_0167, ur, Nx, Ny)
    else:
        ws(alpha_r, dens, data, row_ind, col_ptr, bc_lim, H, H_01, H_67, H_0167, ur, Nx, Ny)
    return

def str_cgs(alpha_r, x, Kg_csc, bc_lim, dKe, ug, Nx, Ny, steps=0, precond="I", serial=False):
    if steps == 0:
        if serial:
            cgs_0_serial(alpha_r, dKe, ug, Nx, Ny)
        else:
            cgs_0(alpha_r, dKe, ug, Nx, Ny)
    else: 
        dens = x.astype("int64")
        data = Kg_csc.data
        row_ind = Kg_csc.indices.astype("int64")
        col_ptr = Kg_csc.indptr.astype("int64")
        if steps == 1:
            if precond == "I":
                if serial:
                    cgs_1I_serial(alpha_r, dens, data, row_ind, col_ptr, bc_lim, dKe, ug, Nx, Ny)
                else:
                    cgs_1I(alpha_r, dens, data, row_ind, col_ptr, bc_lim, dKe, ug, Nx, Ny)
            else:
                if serial:
                    cgs_1J_serial(alpha_r, dens, data, row_ind, col_ptr, bc_lim, dKe, ug, Nx, Ny)
                else:
                    cgs_1J(alpha_r, dens, data, row_ind, col_ptr, bc_lim, dKe, ug, Nx, Ny)
        else:
            if precond == "I":
                if serial:
                    cgs_2I_serial(alpha_r, dens, data, row_ind, col_ptr, bc_lim, dKe, ug, Nx, Ny)
                else:
                    cgs_2I(alpha_r, dens, data, row_ind, col_ptr, bc_lim, dKe, ug, Nx, Ny)
            else:
                if serial:
                    cgs_2J_serial(alpha_r, dens, data, row_ind, col_ptr, bc_lim, dKe, ug, Nx, Ny)
                else:
                    cgs_2J(alpha_r, dens, data, row_ind, col_ptr, bc_lim, dKe, ug, Nx, Ny)
    return

def str_bsens(alpha_r, x, Kg_csc, bc_lim, dKe, ug, Nx, Ny, void_sens=0, serial=False):
    dens = x.astype("int64")
    data = Kg_csc.data
    row_ind = Kg_csc.indices.astype("int64")
    col_ptr = Kg_csc.indptr.astype("int64")
    if serial:
        sens_serial(alpha_r, dens, data, row_ind, col_ptr, bc_lim, dKe, ug, Nx, Ny, void_sens)
    else:
        sens(alpha_r, dens, data, row_ind, col_ptr, bc_lim, dKe, ug, Nx, Ny, void_sens)
    return