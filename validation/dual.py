"""
Dataset Generation
Topology Optimization of a Cantilever Beam
--------------------------------------------------------------------
Laboratory of Topology Optimization and Multiphysics Analysis
Department of Computational Mechanics
School of Mechanical Engineering
University of Campinas (Brazil)
--------------------------------------------------------------------
author  : Daniel Candeloro Cunha
version : 1.0
date    : May 2022
--------------------------------------------------------------------
To collaborate or report bugs, please look for the author's email
address at https://www.fem.unicamp.br/~ltm/

All codes and documentation are publicly available in the following
github repository: https://github.com/Joquempo/Cantilever-Dataset

If you use this program (or the data generated by it) in your work,
the developer would be grateful if you would cite the indicated
references. They are listed in the "CITEAS" file available in the
github repository.
--------------------------------------------------------------------
Copyright (C) 2022 Daniel Candeloro Cunha

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses
"""

import numpy as np
from scipy.sparse import coo_matrix
from sksparse.cholmod import analyze

class Dual:
    def __init__(self, r_val, e_val):
        self.real = np.array(r_val,dtype=float)
        self.epsl = np.array(e_val,dtype=float)
        if self.real.shape != self.epsl.shape:
            raise Exception('real and epsl parts must have the same shape')

    def __repr__(self):
        if self.real.shape == np.array(0).shape:
            if self.epsl >= 0.0:
                return "({:f}+{:f}\u03B5)".format(self.real, self.epsl)
            else:
                return "({:f}{:f}\u03B5)".format(self.real, self.epsl)
        else:
            return "(array + array . \u03B5)"
    def __str__(self):
        if self.real.shape == np.array(0).shape:
            if self.epsl >= 0.0:
                return "({:f}+{:f}\u03B5)".format(self.real, self.epsl)
            else:
                return "({:f}{:f}\u03B5)".format(self.real, self.epsl)
        else:
            return "(array + array . \u03B5)"

    def add(self, d):
        r_val = self.real + d.real
        e_val = self.epsl + d.epsl
        return Dual(r_val,e_val)
    def __add__(self, val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return self.add(v)
    def __radd__(self, val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return v.add(self)

    def sub(self, d):
        r_val = self.real - d.real
        e_val = self.epsl - d.epsl
        return Dual(r_val,e_val)
    def __sub__(self, val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return self.sub(v)
    def __rsub__(self,val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return v.sub(self)
    
    def mul(self, d):
        r_val = self.real * d.real
        e_val = self.epsl * d.real + self.real * d.epsl
        return Dual(r_val,e_val)
    def __mul__(self, val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return self.mul(v)
    def __rmul__(self, val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return v.mul(self)
        
    def matmul(self, d):
        r_val = self.real @ d.real
        e_val = self.epsl @ d.real + self.real @ d.epsl
        return Dual(r_val,e_val)
    def __matmul__(self, val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return self.matmul(v)
    def __rmatmul__(self, val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return v.matmul(self)
    
    def truediv(self, d):
        r_val = self.real / d.real
        e_val = (self.epsl * d.real - self.real * d.epsl) / (d.real * d.real)
        return Dual(r_val,e_val)
    def __truediv__(self,val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return self.truediv(v)
    def __rtruediv__(self,val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return v.truediv(self)

    def log(self):
        r_val = np.log(self.real)
        e_val = self.epsl / self.real
        return Dual(r_val,e_val)
    def exp(self):
        r_val = np.exp(self.real)
        e_val = self.epsl * np.exp(self.real)
        return Dual(r_val,e_val)
    def pow(self, d):
        pot = Dual.exp(d * Dual.log(self))
        r_val = pot.real
        e_val = pot.epsl
        return Dual(r_val,e_val)
    def __pow__(self, val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return self.pow(v)
    def __rpow__(self, val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        return v.pow(self)
    
    def neg(self):
        r_val = -self.real
        e_val = -self.epsl
        return Dual(r_val,e_val)
    def __neg__(self):
        return self.neg()
    
    def sin(self):
        r_val = np.sin(self.real)
        e_val = self.epsl * np.cos(self.real)
        return Dual(r_val,e_val)
    def cos(self):
        r_val = np.cos(self.real)
        e_val = -self.epsl * np.sin(self.real)
        return Dual(r_val,e_val)
    def tan(self):
        return Dual.sin(self)/Dual.cos(self)
    
    def sum(self):
        r_val = self.real.sum()
        e_val = self.epsl.sum()
        return Dual(r_val,e_val)
    
    def getitem(self,key):
        r_val = self.real[key]
        e_val = self.epsl[key]
        return Dual(r_val,e_val)
    def __getitem__(self,key):
        return self.getitem(key)
    
    def setitem(self,key,d):
        self.real[key] = d.real
        self.epsl[key] = d.epsl
    def __setitem__(self,key,val):
        if isinstance(val, Dual):
            v = val
        else:
            val = np.array(val)
            v = Dual(val,np.zeros(val.shape))
        self.setitem(key,v)
    
    def repeat(self,repeats,axis=None):
        r_val = self.real.repeat(repeats,axis)
        e_val = self.epsl.repeat(repeats,axis)
        return Dual(r_val,e_val)
    
    @property
    def T(self):
        r_val = self.real.T
        e_val = self.epsl.T
        return Dual(r_val,e_val)
    
    @staticmethod
    def solver(vector,data,rows,cols,dofs,freeDofs,u_real=None,factor=None):
        mat_coo_epsl = coo_matrix((data.epsl,(rows,cols)),shape=(dofs,dofs))
        mat_csc_epsl = mat_coo_epsl.tocsc()
        matrix_epsl = mat_csc_epsl[freeDofs,:][:,freeDofs]
        if factor is None:
            mat_coo_real = coo_matrix((data.real,(rows,cols)),shape=(dofs,dofs))
            mat_csc_real = mat_coo_real.tocsc()
            matrix_real = mat_csc_real[freeDofs,:][:,freeDofs]
            factor = analyze(matrix_real)
            factor.cholesky_inplace(matrix_real)
        if u_real is None:
            u_real = np.zeros(dofs)
            vec_real = vector.real
            vector_real = vec_real[freeDofs]
            u_real[freeDofs] = factor(vector_real)
        u_epsl = np.zeros(dofs)
        vec_epsl = vector.epsl
        vector_epsl = vec_epsl[freeDofs] - matrix_epsl @ u_real[freeDofs]
        u_epsl[freeDofs] = factor(vector_epsl)
        return Dual(u_real,u_epsl), factor