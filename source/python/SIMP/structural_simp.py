"""
Dataset Generation
Topology Optimization of a Cantilever Beam
--------------------------------------------------------------------
Laboratory of Topology Optimization and Multiphysics Analysis
Department of Computational Mechanics
School of Mechanical Engineering
University of Campinas (Brazil)
--------------------------------------------------------------------
author  : Daniel Candeloro Cunha
version : 1.0
date    : May 2022
--------------------------------------------------------------------
To collaborate or report bugs, please look for the author's email
address at https://www.fem.unicamp.br/~ltm/

All codes and documentation are publicly available in the following
github repository: https://github.com/Joquempo/Cantilever-Dataset

If you use this program (or the data generated by it) in your work,
the developer would be grateful if you would cite the indicated
references. They are listed in the "CITEAS" file available in the
github repository.
--------------------------------------------------------------------
Copyright (C) 2022 Daniel Candeloro Cunha

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses
"""

#%% Imports
import os, sys, gc, pickle
import numpy as np
from time import time
from datetime import datetime
from scipy.sparse import coo_matrix
from sksparse.cholmod import analyze
from structural_mma import solve_mma

sys.path.append('../../cython/')
from structural_ssens import str_ssens

#%% Setup

# fixed properties
p    = [1.0, 3.0, 6.0]  # penalization exponents
meva = [ 16,  16,   0]  # max number of evaluations
miev = [  1,   1,   5]  # max number of inner evaluations

rmax = 0.125      # sensitivity filter radius
Ey = 1.0          # Young's modulus
nu = 0.3          # Poisson's coefficient
epsk = 1e-6       # soft-kill parameter
Ly = 1.0          # cantilever height
small = 1e-14     # small value to compare float numbers

noptf   = 16      # number of optimizations to be stored in the same file
fid_ini = 0       # initial input index |run from input 0
fid_lim = 148240  # input index limit   |up to input 148239

# Elemental Matrix (Quad4) - Plane Stress State
### numbering rule
### 3_____2
### | (e) |
### 0_____1
kk = (Ey/(1-nu**2))*np.array([ 1/2-nu/6 ,  1/8+nu/8, -1/4-nu/12, -1/8+3*nu/8,
                              -1/4+nu/12, -1/8-nu/8,      nu/6 ,  1/8-3*nu/8])
Ke = np.array([[kk[0],kk[1],kk[2],kk[3],kk[4],kk[5],kk[6],kk[7]],
               [kk[1],kk[0],kk[7],kk[6],kk[5],kk[4],kk[3],kk[2]],
               [kk[2],kk[7],kk[0],kk[5],kk[6],kk[3],kk[4],kk[1]],
               [kk[3],kk[6],kk[5],kk[0],kk[7],kk[2],kk[1],kk[4]],
               [kk[4],kk[5],kk[6],kk[7],kk[0],kk[1],kk[2],kk[3]],
               [kk[5],kk[4],kk[3],kk[2],kk[1],kk[0],kk[7],kk[6]],
               [kk[6],kk[3],kk[4],kk[1],kk[2],kk[7],kk[0],kk[5]],
               [kk[7],kk[2],kk[1],kk[4],kk[3],kk[6],kk[5],kk[0]]])
Kevec = Ke.ravel()
dKe = (1.0-epsk)*Ke  # stiffness variation of a topological change

# check directories
if not os.path.exists('../input'):
    os.mkdir('../input')
if not os.path.exists('./output'):
    os.mkdir('./output')
if not os.path.exists('./output/run_{:06d}_{:06d}'.format(fid_ini,fid_lim-1)):
    os.mkdir('./output/run_{:06d}_{:06d}'.format(fid_ini,fid_lim-1))

# check input
if not os.path.exists('../input/inp_000000.pckl'):
    Ny = np.uint32(32)          # number of elements in y-axis
    bc_pos = np.float32(0.0)    # center of the restricted area
    bc_rad = np.float32(0.5)    # half-length (radius) of the restricted area
    ld_pos = np.float32(0.0)    # center of the loaded area
    ld_rad = np.float32(0.125)  # half-length (radius) of the loaded area
    finp = open('../input/inp_000000.pckl','wb')
    pickle.dump([Ny,bc_pos,bc_rad,ld_pos,ld_rad],finp)
    finp.close()

# open log files
if not os.path.exists('./output/run_{:06d}_{:06d}/logs'.format(fid_ini,fid_lim-1)):
    os.mkdir('./output/run_{:06d}_{:06d}/logs'.format(fid_ini,fid_lim-1))
iolog = open('./output/run_{:06d}_{:06d}/logs/io_log.txt'.format(fid_ini,fid_lim-1),'a')
tlog = open('./output/run_{:06d}_{:06d}/logs/time_log.txt'.format(fid_ini,fid_lim-1),'a')
iolog.truncate(0)
tlog.truncate(0)

iolog.write('CONTINUOUS STRUCTURAL OPTIMIZATION (IO LOG)\n')    # write in IO log
iolog.write('=====================================================================================================\n')
iolog.write('= OUTPUT :                input file id :              fid.npy                                      =\n')
iolog.write('= ------ :                   input data :              inp.npy                                      =\n')
iolog.write('= ------ :           optimized topology :       top_p1_opt.npy                                      =\n')
iolog.write('= ------ :            discrete solution :         dtop_opt.npy                                      =\n')
iolog.write('= ------ : optimized objective function :          obj_opt.npy                                      =\n')
iolog.write('= ------ :  discrete solution objective :         dobj_opt.npy                                      =\n')
iolog.write('= ------ : pointer input > optimization :          ptr2opt.npy                                      =\n')
iolog.write('= ------ : pointer optimization > input :          ptr2inp.npy                                      =\n')
iolog.write('= ------ :             topology vectors :           top_p1.npy                                      =\n')
iolog.write('= ------ :        displacements vectors :              dis.npy                                      =\n')
iolog.write('= ------ :          sensitivity vectors :           sen_p1.npy                                      =\n')
iolog.write('= ------ :                 volume array :           vol_p1.npy                                      =\n')
iolog.write('= ------ :             gray level array :           gra_p1.npy                                      =\n')
iolog.write('= ------ :     objective function array :              obj.npy                                      =\n')
iolog.write('= ------ :                   time array :              tim.npy                                      =\n')
iolog.write('=====================================================================================================\n')
iolog.write('       INPUT || ELEM Y :  BC POS : BC RAD :  LD POS : LD RAD ||             BEGIN :               END\n')
tlog.write('CONTINUOUS STRUCTURAL OPTIMIZATION (TIME LOG)\n')   # write in time log
tlog.write('=================================================================================\n') 
tlog.write('       INPUT ||    FILES :     MESH :   B-COND : ASSEMBLY :    OPT-S ||----------\n')
tlog.write('-------------|| (  IT x ):    M-OPT :          :          :   POST-P ||     TOTAL\n')

file = 0  # file counter
fid = fid_ini
while (fid < fid_lim) and (os.path.exists('../input/inp_{:06d}.pckl'.format(fid))):
    if not os.path.exists('./output/run_{:06d}_{:06d}/file_{:05d}'.format(fid_ini,fid_lim-1,file)):
        os.mkdir('./output/run_{:06d}_{:06d}/file_{:05d}'.format(fid_ini,fid_lim-1,file))
    
    list_fid         = []
    list_inp         = []
    list_top_p1_opt  = []
    list_dtop_opt    = []
    list_obj_opt     = []
    list_dobj_opt    = []
    list_ptr2opt     = []
    list_ptr2inp     = []
    list_top_p1      = []
    list_dis         = []
    list_sen_p1      = []
    list_obj         = []
    list_gra_p1      = []
    list_vol_p1      = []
    list_tim         = []
    lists            = [list_ptr2inp, list_top_p1, list_dis, list_sen_p1, list_obj, list_gra_p1, list_vol_p1]
    
    ptr = 0  # pointer to input
    for counter in range(noptf):
        if (fid >= fid_lim) or (not os.path.exists('../input/inp_{:06d}.pckl'.format(fid))):
            break
    
        print('running : {:06d} : setup'.format(fid))
        inp_file = 'inp_{:06d}.pckl'.format(fid)
        iolog.write('> ' + inp_file[:-5] + ' ||')
        tlog.write('> ' + inp_file[:-5] + ' ||')
        
        #%% Read files
        t0 = time()
        
        # read input file
        finp = open('../input/'+inp_file,'rb')
        Ny,bc_pos,bc_rad,ld_pos,ld_rad = pickle.load(finp)
        Ny = int(Ny)
        bc_pos = float(bc_pos)
        bc_rad = float(bc_rad)
        ld_pos = float(ld_pos)
        ld_rad = float(ld_rad)
        finp.close()
        list_fid += [fid]
        list_inp += [[bc_pos,bc_rad,ld_pos,ld_rad]]
        
        # write in log
        iolog.write(' {:6d} :'.format(Ny))
        iolog.write(' {:7.4f} :'.format(bc_pos))
        iolog.write(' {:6.4f} :'.format(bc_rad))
        iolog.write(' {:7.4f} :'.format(ld_pos))
        iolog.write(' {:6.4f} ||'.format(ld_rad))
        iolog.write(datetime.now().strftime(' %y/%m/%d-%H:%M:%S :'))
    
        # input properties
        Nx = 2*Ny      # number of elements in x-axis
        N = Nx*Ny      # total number of elements
        esize = Ly/Ny  # element size
    
        x = 0.5*np.ones(N)  # set initial topology
            
        # write in log
        time_array = np.zeros(9)  # initialize time array
        t1 = time()    
        time_array[0] = t1 - t0
        tlog.write(' {:6.3f} s :'.format(time_array[0]))
    
        #%% Generate Mesh
        t0 = time()
        ### numbering rule
        ### 2_____5_____8_____11
        ### | (1) | (3) | (5) |
        ### 1_____4_____7_____10
        ### | (0) | (2) | (4) |
        ### 0_____3_____6_____9
        
        # coordinates matrix
        xcoor = (Ny+1)*[list(range(Nx+1))]
        xcoor = np.ravel(xcoor,'F')
        ycoor = (Nx+1)*[list(range(Ny+1))]
        ycoor = np.ravel(ycoor,'C')
        coor = esize*np.array([xcoor,ycoor]).T
        coor[:,1] = coor[:,1] - 0.5*Ly
        
        # incidence matrix
        N = Nx*Ny
        G = 2*(Nx+1)*(Ny+1)
        inci = np.ndarray([N,4],dtype=int)
        elem_ids = np.arange(N)
        inci[:,0] = elem_ids + elem_ids//Ny
        inci[:,1] = inci[:,0] + Ny + 1
        inci[:,2] = inci[:,0] + Ny + 2
        inci[:,3] = inci[:,0] + 1
        
        # write in log    
        t1 = time()
        time_array[1] = t1 - t0
        tlog.write(' {:6.3f} s :'.format(time_array[1]))
        
        #%% Boundary Conditions
        t0 = time()
        
        # free DOFs
        bc_ycoor = coor[:Ny+1,1]
        bc_mask = abs(bc_ycoor - bc_pos*Ly) < bc_rad*Ly + small
        if sum(bc_mask) < 2:
            print('insufficient constraint')
            iolog.close()
            tlog.close()
            sys.exit()
        bc_ids = np.arange(0,Ny+1)
        bc_ids = bc_ids[bc_mask]
        bc = np.concatenate((2*bc_ids,2*bc_ids+1))
        freeDofs = np.ones(G,dtype=bool)
        freeDofs[bc] = False
        sys_size = sum(freeDofs)
        
        # load vector
        fg = np.zeros(G)
        ld_ycoor = coor[Nx*(Ny+1):,1]
        ld_mask = abs(ld_ycoor - ld_pos*Ly) < ld_rad*Ly + small
        ld_mask_ele = ld_mask[1:] | ld_mask[:-1]
        ld_ele = np.arange((Nx-1)*Ny,Nx*Ny)
        ld_ele = ld_ele[ld_mask_ele]
        ld_num = sum(ld_mask)
        ld_ids = np.arange(Nx*(Ny+1),(Nx+1)*(Ny+1))
        ld_ids = ld_ids[ld_mask]
        if ld_num == 0:
            pass
        elif ld_num == 1:
            fg[2*ld_ids+1] = -1.0
        else:
            ld_val = -1.0/(ld_num-1)
            fg[2*ld_ids[1:-1]+1] = ld_val    
            fg[2*ld_ids[[0,-1]]+1] = 0.5*ld_val
        fr = fg[freeDofs]
    
        # write in log    
        t1 = time()
        time_array[2] = t1 - t0
        tlog.write(' {:6.3f} s :'.format(time_array[2]))
        
        #%% Matrix Assembly
        t0 = time()
        
        # COO data
        pen = epsk + (1.0-epsk)*(x**p[0])
        pen = pen.repeat(64)
        data = pen*np.tile(Kevec,N)
    
        # COO indices
        dof0 = 2*inci[:,0]
        dof1 = dof0 + 1
        dof2 = 2*inci[:,1]
        dof3 = dof2 + 1
        dof4 = 2*inci[:,2]
        dof5 = dof4 + 1
        dof6 = 2*inci[:,3]
        dof7 = dof6 + 1
        eledofs = np.array([dof0,dof1,dof2,dof3,dof4,dof5,dof6,dof7])
        row = eledofs.repeat(8,axis=0).ravel('F')
        col = eledofs.T.repeat(8,axis=0).ravel('C')
        
        # stiffness matrix
        Kg_coo = coo_matrix((data,(row,col)),shape=(G,G))
        Kg_csc = Kg_coo.tocsc()
        Kr = Kg_csc[freeDofs,:][:,freeDofs]
        
        # write in log    
        t1 = time()
        time_array[3] = t1 - t0
        tlog.write(' {:6.3f} s :'.format(time_array[3]))
        
        #%% Optimization Setup
        t0 = time()
        
        # analyze sparse matrix
        factor = analyze(Kr)
    
        # write in log
        t1 = time()
        time_array[4] = t1 - t0
        tlog.write(' {:6.3f} s ||----------\n'.format(time_array[4]))
    
        #%% Optimization (MMA-SIMP)
        t0=time()
        
        size_list = len(list_ptr2inp)
        list_ptr2opt += [size_list]
        i0 = len(list_obj)
        for k in range(len(p)):
            print('------- : ------ : p = {:.1f} : max_eval = {:02d}'.format(p[k],meva[k]))
            x, h = solve_mma(x, p[k], epsk, row, col, Nx, Ny, G, Kevec, dKe, freeDofs, fr, rmax, esize,
                             lists, ptr, factor, meval=meva[k], inner_meval=miev[k])
            it = len(list_obj)-i0-1
            print('------- : ------ : [{:4d} iterations]'.format(it))
        list_top_p1_opt += [x**p[-1]]
        list_obj_opt    += [h]

        t1 = time()
        time_array[5] = t1 - t0
        
        #%% Post-Processing
        t0=time()
        
        # obtain discrete solution
        x[ld_ele] = 1.0
        y = np.ones(N,dtype=bool)
        y[np.argsort(x)[:N//2]] = False
        
        ug = np.zeros(G)
        pen = np.ones(N)
        pen[~y] = epsk
        pen = pen.repeat(64)
        data = pen*np.tile(Kevec,N)
        Kg_coo = coo_matrix((data,(row,col)),shape=(G,G))
        Kg_csc = Kg_coo.tocsc()
        Kr = Kg_csc[freeDofs,:][:,freeDofs]
        factor.cholesky_inplace(Kr)
        ug[freeDofs] = factor(fr)
        h = np.dot(ug[freeDofs],fr)
        
        t1 = time()
        time_array[6] = t1 - t0
        
        # write in log
        tlog.write('-------------|| ({:4d} x ):'.format(it))
        time_array[7] = sum(time_array[:7])
        time_array[5] = time_array[5]/it
        time_array[8] = (1+small)*it
        tlog.write(' {:6.3f} s :          :          : {:6.3f} s ||'.format(time_array[5],time_array[6]))
        tlog.write(' {:7.1f} s\n'.format(time_array[7]))
        iolog.write(datetime.now().strftime(' %y/%m/%d-%H:%M:%S\n'))
        
        list_dtop_opt += [y.copy()]
        list_dobj_opt += [h]
        list_obj      += [h]
        list_gra_p1   += [4*np.mean(y*(1.0-y))]
        list_vol_p1   += [sum(y)/N]
        list_ptr2inp  += [ptr]
        list_top_p1   += [y.astype(float)]
        list_dis      += [ug.copy()]
        alpha_r = np.zeros(N)
        str_ssens(alpha_r, y.astype(float), dKe, ug, 1.0, Nx, Ny)
        list_sen_p1   += [alpha_r.copy()]
        list_tim      += [time_array.copy()]
        
        # update pointer
        ptr = ptr + 1
        
        # prepare to open next input file
        fid = fid + 1

    #%% Write files
    size_list = len(list_ptr2inp)
    list_ptr2opt += [size_list]

    # save files
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/fid.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_fid,dtype=np.uint32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/inp.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_inp,dtype=np.float32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/top_p1_opt.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_top_p1_opt,dtype=np.float32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/dtop_opt.npy'.format(
        fid_ini,fid_lim-1,file),np.packbits(np.array(list_dtop_opt),axis=1))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/obj_opt.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_obj_opt,dtype=np.float32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/dobj_opt.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_dobj_opt,dtype=np.float32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/ptr2opt.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_ptr2opt,dtype=np.uint32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/ptr2inp.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_ptr2inp,dtype=np.uint32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/top_p1.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_top_p1,dtype=np.float32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/dis.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_dis,dtype=np.float32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/sen_p1.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_sen_p1,dtype=np.float32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/obj.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_obj,dtype=np.float32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/gra_p1.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_gra_p1,dtype=np.float32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/vol_p1.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_vol_p1,dtype=np.float32))
    np.save('./output/run_{:06d}_{:06d}/file_{:05d}/tim.npy'.format(
        fid_ini,fid_lim-1,file),np.array(list_tim,dtype=np.float32))
    
    del lists, list_fid, list_inp, list_top_p1_opt, list_dtop_opt, list_obj_opt, list_dobj_opt
    del list_ptr2opt, list_ptr2inp, list_top_p1, list_dis, list_sen_p1, list_obj, list_gra_p1, list_vol_p1, list_tim
    gc.collect()
    
    # prepare to write next output file
    file = file + 1

#%% close log files
iolog.close()
tlog.close()
print('done!')
