"""
Dataset Generation
Topology Optimization of a Cantilever Beam
--------------------------------------------------------------------
Laboratory of Topology Optimization and Multiphysics Analysis
Department of Computational Mechanics
School of Mechanical Engineering
University of Campinas (Brazil)
--------------------------------------------------------------------
author  : Daniel Candeloro Cunha
version : 1.0
date    : May 2022
--------------------------------------------------------------------
To collaborate or report bugs, please look for the author's email
address at https://www.fem.unicamp.br/~ltm/

All codes and documentation are publicly available in the following
github repository: https://github.com/Joquempo/Cantilever-Dataset

If you use this program (or the data generated by it) in your work,
the developer would be grateful if you would cite the indicated
references. They are listed in the "CITEAS" file available in the
github repository.
--------------------------------------------------------------------
Copyright (C) 2022 Daniel Candeloro Cunha

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see https://www.gnu.org/licenses
"""

# cython: boundscheck=False
# cython: wraparound=False
# cython: cdivision=True

cimport cython
from libc.math cimport sqrt
from libc.stdlib cimport malloc, free

cdef void sfilter_serial(double [:] alpha_r, double [:] alpha_f, double rm, long long Nx, long long Ny):
    cdef long long N
    cdef long long e
    N = Nx*Ny
    if rm <= 1.0:
        for e in range(N):
            alpha_f[e] = alpha_r[e]
        return
    cdef long long k1
    cdef long long k2
    cdef long long row
    cdef long long col
    cdef long long center
    cdef long long Rmax
    cdef long long Rbot
    cdef long long Rtop
    cdef long long Rlef
    cdef long long Rrig
    cdef double rmax_sq
    cdef double dist_sq
    cdef double weights_sum
    Rmax = <long long> rm
    center = 2*Rmax*(Rmax+1)
    rmax_sq = rm*rm
    cdef double *weights  = <double *> malloc((2*Rmax+1)*(2*Rmax+1)*sizeof(double))
    cdef double *weights0 = <double *> malloc((2*Rmax+1)*(2*Rmax+1)*sizeof(double))
    # conical filter weights
    weights_sum = 0.0
    for k1 in range(-Rmax,Rmax+1):
        for k2 in range(-Rmax,Rmax+1):
            dist_sq = k1*k1 + k2*k2
            if dist_sq > rmax_sq:
                weights[center+k1+k2*(2*Rmax+1)] = 0.0
            else:
                weights[center+k1+k2*(2*Rmax+1)] = rm - sqrt(dist_sq)
                weights_sum = weights_sum + weights[center+k1+k2*(2*Rmax+1)]
    for k1 in range((2*Rmax+1)*(2*Rmax+1)):
        weights0[k1] = weights[k1]/weights_sum
    for e in range(N):
        # submesh under the filter's influence
        row = e % Ny
        col = e // Ny
        Rbot = Rmax
        Rtop = Rmax
        Rlef = Rmax
        Rrig = Rmax
        if row < Rmax:
            Rbot = row
        if row > Ny-1-Rmax:
            Rtop = Ny-1-row
        if col < Rmax:
            Rlef = col
        if col > Nx-1-Rmax:
            Rrig = Nx-1-col
        # filtered sensitivity vector
        alpha_f[e] = 0.0
        if Rbot+Rtop+Rlef+Rrig < 4*Rmax:
            weights_sum = 0.0
            for k1 in range(-Rbot,Rtop+1):
                for k2 in range(-Rlef,Rrig+1):
                    weights_sum = weights_sum + weights[center+k1+k2*(2*Rmax+1)]
            for k1 in range(-Rbot,Rtop+1):
                for k2 in range(-Rlef,Rrig+1):            
                    alpha_f[e] = alpha_f[e] + alpha_r[e+k1+k2*Ny]*(weights[center+k1+k2*(2*Rmax+1)]/weights_sum)
        else:
            for k1 in range(-Rbot,Rtop+1):
                for k2 in range(-Rlef,Rrig+1):            
                    alpha_f[e] = alpha_f[e] + alpha_r[e+k1+k2*Ny]*weights0[center+k1+k2*(2*Rmax+1)]
    free(weights)
    free(weights0)
    return

cdef void sfilter_noload_serial(double [:] alpha_r, double [:] alpha_f, double rm, long long Nx, long long Ny, long long [:] ld_lim):
    cdef long long N
    cdef long long e
    cdef long long v0
    cdef long long v1
    N = Nx*Ny
    v0 = ld_lim[0]
    v1 = ld_lim[1]
    if rm <= 1.0:
        for e in range(N):
            if e >= v0 and e <= v1:
                alpha_f[e] = 0.0
            else:           
                alpha_f[e] = alpha_r[e]
        return
    cdef long long k1
    cdef long long k2
    cdef long long k3
    cdef long long ld_lim_0
    cdef long long ld_lim_1
    cdef long long row
    cdef long long col
    cdef long long center
    cdef long long Rmax
    cdef long long Rbot
    cdef long long Rtop
    cdef long long Rlef
    cdef long long Rrig
    cdef double rmax_sq
    cdef double dist_sq
    cdef double weights_sum
    Rmax = <long long> rm
    center = 2*Rmax*(Rmax+1)
    rmax_sq = rm*rm
    cdef double *weights  = <double *> malloc((2*Rmax+1)*(2*Rmax+1)*sizeof(double))
    cdef double *weights0 = <double *> malloc((2*Rmax+1)*(2*Rmax+1)*sizeof(double))
    # conical filter weights
    weights_sum = 0.0
    for k1 in range(-Rmax,Rmax+1):
        for k2 in range(-Rmax,Rmax+1):
            dist_sq = k1*k1 + k2*k2
            if dist_sq > rmax_sq:
                weights[center+k1+k2*(2*Rmax+1)] = 0.0
            else:
                weights[center+k1+k2*(2*Rmax+1)] = rm - sqrt(dist_sq)
                weights_sum = weights_sum + weights[center+k1+k2*(2*Rmax+1)]
    for k1 in range((2*Rmax+1)*(2*Rmax+1)):
        weights0[k1] = weights[k1]/weights_sum
    ld_lim_0 = v0 % Ny
    ld_lim_1 = v1 % Ny    
    for e in range(N):
        if e >= v0 and e <= v1:
            alpha_f[e] = 0.0
        else:
            # submesh under the filter's influence
            row = e % Ny
            col = e // Ny
            Rbot = Rmax
            Rtop = Rmax
            Rlef = Rmax
            Rrig = Rmax
            if row < Rmax:
                Rbot = row
            if row > Ny-1-Rmax:
                Rtop = Ny-1-row
            if col < Rmax:
                Rlef = col
            if col > Nx-1-Rmax:
                Rrig = Nx-1-col
            # filtered sensitivity vector
            alpha_f[e] = 0.0
            if col >= Nx-1-Rmax:  # ignore loaded elements
                weights_sum = 0.0
                for k1 in range(-Rbot,Rtop+1):
                    for k2 in range(-Rlef,Rrig):
                        weights_sum = weights_sum + weights[center+k1+k2*(2*Rmax+1)]
                k2 = Rrig
                if (row+Rtop < ld_lim_0) or (row-Rbot > ld_lim_1):
                    for k1 in range(-Rbot,Rtop+1):
                        weights_sum = weights_sum + weights[center+k1+k2*(2*Rmax+1)]
                else:
                    if row-Rbot < ld_lim_0:
                        for k3 in range(row-Rbot,ld_lim_0):
                            k1 = k3 - row
                            weights_sum = weights_sum + weights[center+k1+k2*(2*Rmax+1)]
                    if row+Rtop > ld_lim_1:
                        for k3 in range(ld_lim_1+1,row+Rtop+1):
                            k1 = k3 - row
                            weights_sum = weights_sum + weights[center+k1+k2*(2*Rmax+1)]
                for k1 in range(-Rbot,Rtop+1):
                    for k2 in range(-Rlef,Rrig):            
                        alpha_f[e] = alpha_f[e] + alpha_r[e+k1+k2*Ny]*(weights[center+k1+k2*(2*Rmax+1)]/weights_sum)
                k2 = Rrig
                if (row+Rtop < ld_lim_0) or (row-Rbot > ld_lim_1):
                    for k1 in range(-Rbot,Rtop+1):
                        alpha_f[e] = alpha_f[e] + alpha_r[e+k1+k2*Ny]*(weights[center+k1+k2*(2*Rmax+1)]/weights_sum)
                else:
                    if row-Rbot < ld_lim_0:
                        for k3 in range(row-Rbot,ld_lim_0):
                            k1 = k3 - row
                            alpha_f[e] = alpha_f[e] + alpha_r[e+k1+k2*Ny]*(weights[center+k1+k2*(2*Rmax+1)]/weights_sum)
                    if row+Rtop > ld_lim_1:
                        for k3 in range(ld_lim_1+1,row+Rtop+1):
                            k1 = k3 - row
                            alpha_f[e] = alpha_f[e] + alpha_r[e+k1+k2*Ny]*(weights[center+k1+k2*(2*Rmax+1)]/weights_sum)
            else:                 # no loaded elements to ignore
                if Rbot+Rtop+Rlef+Rrig < 4*Rmax:
                    weights_sum = 0.0
                    for k1 in range(-Rbot,Rtop+1):
                        for k2 in range(-Rlef,Rrig+1):
                            weights_sum = weights_sum + weights[center+k1+k2*(2*Rmax+1)]
                    for k1 in range(-Rbot,Rtop+1):
                        for k2 in range(-Rlef,Rrig+1):            
                            alpha_f[e] = alpha_f[e] + alpha_r[e+k1+k2*Ny]*(weights[center+k1+k2*(2*Rmax+1)]/weights_sum)
                else:
                    for k1 in range(-Rbot,Rtop+1):
                        for k2 in range(-Rlef,Rrig+1):            
                            alpha_f[e] = alpha_f[e] + alpha_r[e+k1+k2*Ny]*weights0[center+k1+k2*(2*Rmax+1)]
    free(weights)
    free(weights0)
    return

def str_filter(alpha_r, alpha_f, rmax, esize, Nx, Ny, load_lim=None):
    rm = rmax/esize
    if load_lim is None:
        sfilter_serial(alpha_r, alpha_f, rm, Nx, Ny)
    else:
        sfilter_noload_serial(alpha_r, alpha_f, rm, Nx, Ny, load_lim)
    return